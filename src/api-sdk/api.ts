/* tslint:disable */
/* eslint-disable */
/**
 * USAsset API Service
 *      USAsset API Service with Role-Based Access Control (RBAC)          ## Authentication     This API supports two authentication methods:     1. **API Key**: Use \'x-api-key\' header for basic authentication     2. **JWT Bearer Token**: Use \'Authorization: Bearer <token>\' for RBAC-protected endpoints          ## Permission System     RBAC endpoints require specific permissions in the format \'action:resource\':     - **Actions**: view, create, edit, delete     - **Resources**: project, location, asset, user          ## System Roles     - **project_admin**: Full project access (all permissions)     - **project_manager**: Manage resources (no user management)     - **engineer**: Edit assets/locations only     - **viewer**: Read-only access          ## Error Responses     - **401 Unauthorized**: Missing or invalid authentication     - **403 Forbidden**: Missing required permission     - **404 Not Found**: Resource not found   
 *
 * The version of the OpenAPI document: 1.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from './configuration';
import type { AxiosPromise, AxiosInstance, RawAxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
import type { RequestArgs } from './base';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, BaseAPI, RequiredError, operationServerMap } from './base';

/**
 * 
 * @export
 * @interface ApiPaginatedResponseDto
 */
export interface ApiPaginatedResponseDto {
    /**
     * Indicates if the request was successful
     * @type {boolean}
     * @memberof ApiPaginatedResponseDto
     */
    'success': boolean;
    /**
     * Paginated data with items and metadata
     * @type {object}
     * @memberof ApiPaginatedResponseDto
     */
    'data': object;
    /**
     * Optional message
     * @type {string}
     * @memberof ApiPaginatedResponseDto
     */
    'message'?: string;
    /**
     * Timestamp of the response
     * @type {string}
     * @memberof ApiPaginatedResponseDto
     */
    'timestamp': string;
    /**
     * Request path
     * @type {string}
     * @memberof ApiPaginatedResponseDto
     */
    'path': string;
}
/**
 * 
 * @export
 * @interface ApiResponseDto
 */
export interface ApiResponseDto {
    /**
     * Indicates if the request was successful
     * @type {boolean}
     * @memberof ApiResponseDto
     */
    'success': boolean;
    /**
     * Response data
     * @type {object}
     * @memberof ApiResponseDto
     */
    'data': object;
    /**
     * Optional message
     * @type {string}
     * @memberof ApiResponseDto
     */
    'message'?: string;
    /**
     * Timestamp of the response
     * @type {string}
     * @memberof ApiResponseDto
     */
    'timestamp': string;
    /**
     * Request path
     * @type {string}
     * @memberof ApiResponseDto
     */
    'path': string;
}
/**
 * 
 * @export
 * @interface AssignRoleDto
 */
export interface AssignRoleDto {
    /**
     * Name of the role to assign
     * @type {string}
     * @memberof AssignRoleDto
     */
    'roleName': AssignRoleDtoRoleNameEnum;
    /**
     * Optional reason for the role assignment
     * @type {string}
     * @memberof AssignRoleDto
     */
    'reason'?: string;
}

/**
    * @export
    * @enum {string}
    */
export enum AssignRoleDtoRoleNameEnum {
    ProjectAdmin = 'project_admin',
    ProjectManager = 'project_manager',
    Engineer = 'engineer',
    Viewer = 'viewer'
}

/**
 * 
 * @export
 * @interface AuditLogEntryDto
 */
export interface AuditLogEntryDto {
    /**
     * Audit log entry ID
     * @type {string}
     * @memberof AuditLogEntryDto
     */
    'id': string;
    /**
     * Action performed
     * @type {string}
     * @memberof AuditLogEntryDto
     */
    'action': AuditLogEntryDtoActionEnum;
    /**
     * User ID who received/lost the role
     * @type {string}
     * @memberof AuditLogEntryDto
     */
    'userId': string;
    /**
     * Email of the user who received/lost the role
     * @type {string}
     * @memberof AuditLogEntryDto
     */
    'userEmail': string;
    /**
     * Name of the user who received/lost the role
     * @type {string}
     * @memberof AuditLogEntryDto
     */
    'userName': string;
    /**
     * Project ID where the change occurred
     * @type {string}
     * @memberof AuditLogEntryDto
     */
    'projectId': string;
    /**
     * Name of the project
     * @type {string}
     * @memberof AuditLogEntryDto
     */
    'projectName': string;
    /**
     * Role ID that was assigned/removed
     * @type {string}
     * @memberof AuditLogEntryDto
     */
    'roleId': string;
    /**
     * Name of the role
     * @type {string}
     * @memberof AuditLogEntryDto
     */
    'roleName': string;
    /**
     * User ID who performed the action
     * @type {string}
     * @memberof AuditLogEntryDto
     */
    'performedBy': string;
    /**
     * Email of the admin who performed the action
     * @type {string}
     * @memberof AuditLogEntryDto
     */
    'performedByEmail': string;
    /**
     * Name of the admin who performed the action
     * @type {string}
     * @memberof AuditLogEntryDto
     */
    'performedByName': string;
    /**
     * Optional reason for the change
     * @type {object}
     * @memberof AuditLogEntryDto
     */
    'reason': object | null;
    /**
     * Timestamp when the action occurred
     * @type {string}
     * @memberof AuditLogEntryDto
     */
    'timestamp': string;
}

/**
    * @export
    * @enum {string}
    */
export enum AuditLogEntryDtoActionEnum {
    RoleAssigned = 'role_assigned',
    RoleRemoved = 'role_removed',
    BulkRoleAssigned = 'bulk_role_assigned'
}

/**
 * 
 * @export
 * @interface AuditLogPaginationDto
 */
export interface AuditLogPaginationDto {
    /**
     * Total number of audit log entries
     * @type {number}
     * @memberof AuditLogPaginationDto
     */
    'total': number;
    /**
     * Current page number
     * @type {number}
     * @memberof AuditLogPaginationDto
     */
    'page': number;
    /**
     * Number of items per page
     * @type {number}
     * @memberof AuditLogPaginationDto
     */
    'limit': number;
    /**
     * Total number of pages
     * @type {number}
     * @memberof AuditLogPaginationDto
     */
    'totalPages': number;
}
/**
 * 
 * @export
 * @interface AuditLogResponseDto
 */
export interface AuditLogResponseDto {
    /**
     * List of audit log entries
     * @type {Array<AuditLogEntryDto>}
     * @memberof AuditLogResponseDto
     */
    'logs': Array<AuditLogEntryDto>;
    /**
     * Pagination information
     * @type {AuditLogPaginationDto}
     * @memberof AuditLogResponseDto
     */
    'pagination': AuditLogPaginationDto;
}
/**
 * 
 * @export
 * @interface AuthControllerGetProfile200Response
 */
export interface AuthControllerGetProfile200Response {
    /**
     * 
     * @type {boolean}
     * @memberof AuthControllerGetProfile200Response
     */
    'success'?: boolean;
    /**
     * 
     * @type {AuthControllerGetProfile200ResponseData}
     * @memberof AuthControllerGetProfile200Response
     */
    'data'?: AuthControllerGetProfile200ResponseData;
}
/**
 * 
 * @export
 * @interface AuthControllerGetProfile200ResponseData
 */
export interface AuthControllerGetProfile200ResponseData {
    /**
     * 
     * @type {string}
     * @memberof AuthControllerGetProfile200ResponseData
     */
    'userId'?: string;
    /**
     * 
     * @type {string}
     * @memberof AuthControllerGetProfile200ResponseData
     */
    'email'?: string;
    /**
     * 
     * @type {string}
     * @memberof AuthControllerGetProfile200ResponseData
     */
    'projectId'?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof AuthControllerGetProfile200ResponseData
     */
    'permissions'?: Array<string>;
}
/**
 * 
 * @export
 * @interface AuthControllerLogin200Response
 */
export interface AuthControllerLogin200Response {
    /**
     * 
     * @type {boolean}
     * @memberof AuthControllerLogin200Response
     */
    'success'?: boolean;
    /**
     * 
     * @type {AuthControllerLogin200ResponseData}
     * @memberof AuthControllerLogin200Response
     */
    'data'?: AuthControllerLogin200ResponseData;
}
/**
 * 
 * @export
 * @interface AuthControllerLogin200ResponseData
 */
export interface AuthControllerLogin200ResponseData {
    /**
     * 
     * @type {string}
     * @memberof AuthControllerLogin200ResponseData
     */
    'accessToken'?: string;
    /**
     * 
     * @type {string}
     * @memberof AuthControllerLogin200ResponseData
     */
    'tokenType'?: string;
    /**
     * 
     * @type {number}
     * @memberof AuthControllerLogin200ResponseData
     */
    'expiresIn'?: number;
}
/**
 * 
 * @export
 * @interface BulkAssignRoleDto
 */
export interface BulkAssignRoleDto {
    /**
     * Name of the role to assign to all users
     * @type {string}
     * @memberof BulkAssignRoleDto
     */
    'roleName': BulkAssignRoleDtoRoleNameEnum;
    /**
     * List of users to assign the role to
     * @type {Array<UserAssignmentDto>}
     * @memberof BulkAssignRoleDto
     */
    'assignments': Array<UserAssignmentDto>;
    /**
     * Optional reason for the bulk role assignment
     * @type {string}
     * @memberof BulkAssignRoleDto
     */
    'reason'?: string;
}

/**
    * @export
    * @enum {string}
    */
export enum BulkAssignRoleDtoRoleNameEnum {
    ProjectAdmin = 'project_admin',
    ProjectManager = 'project_manager',
    Engineer = 'engineer',
    Viewer = 'viewer'
}

/**
 * 
 * @export
 * @interface BulkOperationItemResultDto
 */
export interface BulkOperationItemResultDto {
    /**
     * User ID
     * @type {string}
     * @memberof BulkOperationItemResultDto
     */
    'userId': string;
    /**
     * Project ID
     * @type {string}
     * @memberof BulkOperationItemResultDto
     */
    'projectId': string;
    /**
     * Whether the operation succeeded
     * @type {boolean}
     * @memberof BulkOperationItemResultDto
     */
    'success': boolean;
    /**
     * Error message if the operation failed
     * @type {string}
     * @memberof BulkOperationItemResultDto
     */
    'error'?: string;
}
/**
 * 
 * @export
 * @interface BulkOperationResultDto
 */
export interface BulkOperationResultDto {
    /**
     * Total number of operations attempted
     * @type {number}
     * @memberof BulkOperationResultDto
     */
    'totalOperations': number;
    /**
     * Number of successful operations
     * @type {number}
     * @memberof BulkOperationResultDto
     */
    'successCount': number;
    /**
     * Number of failed operations
     * @type {number}
     * @memberof BulkOperationResultDto
     */
    'failureCount': number;
    /**
     * Detailed results for each operation
     * @type {Array<BulkOperationItemResultDto>}
     * @memberof BulkOperationResultDto
     */
    'results': Array<BulkOperationItemResultDto>;
}
/**
 * 
 * @export
 * @interface CreateLocationDto
 */
export interface CreateLocationDto {
    /**
     * Location name
     * @type {string}
     * @memberof CreateLocationDto
     */
    'name': string;
}
/**
 * 
 * @export
 * @interface CreateProjectDto
 */
export interface CreateProjectDto {
    /**
     * Project name
     * @type {string}
     * @memberof CreateProjectDto
     */
    'name': string;
    /**
     * User ID who owns this project (optional)
     * @type {string}
     * @memberof CreateProjectDto
     */
    'userId'?: string;
}
/**
 * 
 * @export
 * @interface CreateUserDto
 */
export interface CreateUserDto {
    /**
     * 
     * @type {string}
     * @memberof CreateUserDto
     */
    'email': string;
    /**
     * 
     * @type {string}
     * @memberof CreateUserDto
     */
    'name': string;
}
/**
 * 
 * @export
 * @interface HealthControllerCheck200Response
 */
export interface HealthControllerCheck200Response {
    /**
     * 
     * @type {string}
     * @memberof HealthControllerCheck200Response
     */
    'status'?: string;
    /**
     * 
     * @type {string}
     * @memberof HealthControllerCheck200Response
     */
    'timestamp'?: string;
}
/**
 * 
 * @export
 * @interface HealthControllerExportAuditLogs200ResponseInner
 */
export interface HealthControllerExportAuditLogs200ResponseInner {
    /**
     * 
     * @type {number}
     * @memberof HealthControllerExportAuditLogs200ResponseInner
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof HealthControllerExportAuditLogs200ResponseInner
     */
    'timestamp'?: string;
    /**
     * 
     * @type {string}
     * @memberof HealthControllerExportAuditLogs200ResponseInner
     */
    'request_id'?: string;
    /**
     * 
     * @type {string}
     * @memberof HealthControllerExportAuditLogs200ResponseInner
     */
    'event_type'?: string;
    /**
     * 
     * @type {string}
     * @memberof HealthControllerExportAuditLogs200ResponseInner
     */
    'resource'?: string;
    /**
     * 
     * @type {string}
     * @memberof HealthControllerExportAuditLogs200ResponseInner
     */
    'action'?: string;
    /**
     * 
     * @type {number}
     * @memberof HealthControllerExportAuditLogs200ResponseInner
     */
    'status_code'?: number;
}
/**
 * 
 * @export
 * @interface LocationDto
 */
export interface LocationDto {
    /**
     * Location ID
     * @type {string}
     * @memberof LocationDto
     */
    'id': string;
    /**
     * Location name
     * @type {string}
     * @memberof LocationDto
     */
    'name': string;
    /**
     * Project ID this location belongs to
     * @type {string}
     * @memberof LocationDto
     */
    'projectId': string;
}
/**
 * 
 * @export
 * @interface LocationsControllerCreate200Response
 */
export interface LocationsControllerCreate200Response {
    /**
     * Indicates if the request was successful
     * @type {boolean}
     * @memberof LocationsControllerCreate200Response
     */
    'success': boolean;
    /**
     * 
     * @type {LocationDto}
     * @memberof LocationsControllerCreate200Response
     */
    'data': LocationDto;
    /**
     * Optional message
     * @type {string}
     * @memberof LocationsControllerCreate200Response
     */
    'message'?: string;
    /**
     * Timestamp of the response
     * @type {string}
     * @memberof LocationsControllerCreate200Response
     */
    'timestamp': string;
    /**
     * Request path
     * @type {string}
     * @memberof LocationsControllerCreate200Response
     */
    'path': string;
}
/**
 * 
 * @export
 * @interface LocationsControllerFindPaginated200Response
 */
export interface LocationsControllerFindPaginated200Response {
    /**
     * Indicates if the request was successful
     * @type {boolean}
     * @memberof LocationsControllerFindPaginated200Response
     */
    'success': boolean;
    /**
     * 
     * @type {LocationsControllerFindPaginated200ResponseAllOfData}
     * @memberof LocationsControllerFindPaginated200Response
     */
    'data': LocationsControllerFindPaginated200ResponseAllOfData;
    /**
     * Optional message
     * @type {string}
     * @memberof LocationsControllerFindPaginated200Response
     */
    'message'?: string;
    /**
     * Timestamp of the response
     * @type {string}
     * @memberof LocationsControllerFindPaginated200Response
     */
    'timestamp': string;
    /**
     * Request path
     * @type {string}
     * @memberof LocationsControllerFindPaginated200Response
     */
    'path': string;
}
/**
 * 
 * @export
 * @interface LocationsControllerFindPaginated200ResponseAllOfData
 */
export interface LocationsControllerFindPaginated200ResponseAllOfData {
    /**
     * 
     * @type {Array<LocationDto>}
     * @memberof LocationsControllerFindPaginated200ResponseAllOfData
     */
    'items'?: Array<LocationDto>;
}
/**
 * 
 * @export
 * @interface MyPermissionsDto
 */
export interface MyPermissionsDto {
    /**
     * User ID
     * @type {string}
     * @memberof MyPermissionsDto
     */
    'userId': string;
    /**
     * Active project ID
     * @type {object}
     * @memberof MyPermissionsDto
     */
    'projectId'?: object | null;
    /**
     * Project code
     * @type {object}
     * @memberof MyPermissionsDto
     */
    'projectCode'?: object | null;
    /**
     * Project name
     * @type {object}
     * @memberof MyPermissionsDto
     */
    'projectName'?: object | null;
    /**
     * List of role names assigned to the user
     * @type {Array<string>}
     * @memberof MyPermissionsDto
     */
    'roles': Array<string>;
    /**
     * List of permissions available to the user
     * @type {Array<string>}
     * @memberof MyPermissionsDto
     */
    'permissions': Array<string>;
    /**
     * Timestamp when this permission set was issued
     * @type {string}
     * @memberof MyPermissionsDto
     */
    'issuedAt': string;
}
/**
 * 
 * @export
 * @interface PermissionCheckResultDto
 */
export interface PermissionCheckResultDto {
    /**
     * Whether the user has the requested permission
     * @type {boolean}
     * @memberof PermissionCheckResultDto
     */
    'hasPermission': boolean;
    /**
     * The permission that was checked
     * @type {string}
     * @memberof PermissionCheckResultDto
     */
    'permission': string;
    /**
     * User ID that was checked
     * @type {string}
     * @memberof PermissionCheckResultDto
     */
    'userId': string;
    /**
     * Project ID where the permission was checked
     * @type {object}
     * @memberof PermissionCheckResultDto
     */
    'projectId'?: object | null;
}
/**
 * 
 * @export
 * @interface PermissionDto
 */
export interface PermissionDto {
    /**
     * Unique identifier of the permission
     * @type {string}
     * @memberof PermissionDto
     */
    'id': string;
    /**
     * Action part of the permission
     * @type {string}
     * @memberof PermissionDto
     */
    'action': string;
    /**
     * Resource part of the permission
     * @type {string}
     * @memberof PermissionDto
     */
    'resource': string;
    /**
     * Human-readable description of what this permission allows
     * @type {object}
     * @memberof PermissionDto
     */
    'description'?: object;
    /**
     * Full permission string in action:resource format
     * @type {string}
     * @memberof PermissionDto
     */
    'permissionString': string;
}
/**
 * 
 * @export
 * @interface PermissionMatrixDto
 */
export interface PermissionMatrixDto {
    /**
     * Map of role names to their permission information
     * @type {{ [key: string]: PermissionMatrixDtoRolesValue; }}
     * @memberof PermissionMatrixDto
     */
    'roles': { [key: string]: PermissionMatrixDtoRolesValue; };
    /**
     * List of all unique resources in the system
     * @type {Array<string>}
     * @memberof PermissionMatrixDto
     */
    'resources': Array<string>;
    /**
     * List of all unique actions in the system
     * @type {Array<string>}
     * @memberof PermissionMatrixDto
     */
    'actions': Array<string>;
}
/**
 * 
 * @export
 * @interface PermissionMatrixDtoRolesValue
 */
export interface PermissionMatrixDtoRolesValue {
    /**
     * 
     * @type {string}
     * @memberof PermissionMatrixDtoRolesValue
     */
    'displayName'?: string;
    /**
     * 
     * @type {string}
     * @memberof PermissionMatrixDtoRolesValue
     */
    'description'?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof PermissionMatrixDtoRolesValue
     */
    'permissions'?: Array<string>;
}
/**
 * 
 * @export
 * @interface ProjectDto
 */
export interface ProjectDto {
    /**
     * Project ID
     * @type {string}
     * @memberof ProjectDto
     */
    'id': string;
    /**
     * Project name
     * @type {string}
     * @memberof ProjectDto
     */
    'name': string;
    /**
     * User ID who created the project
     * @type {object}
     * @memberof ProjectDto
     */
    'userId'?: object;
    /**
     * Creation timestamp
     * @type {string}
     * @memberof ProjectDto
     */
    'createdAt': string;
}
/**
 * 
 * @export
 * @interface ProjectInfoDto
 */
export interface ProjectInfoDto {
    /**
     * Project ID
     * @type {string}
     * @memberof ProjectInfoDto
     */
    'id': string;
    /**
     * Project name
     * @type {string}
     * @memberof ProjectInfoDto
     */
    'name': string;
}
/**
 * 
 * @export
 * @interface ProjectStatsDto
 */
export interface ProjectStatsDto {
    /**
     * Total number of projects
     * @type {number}
     * @memberof ProjectStatsDto
     */
    'totalProjects': number;
    /**
     * Number of projects created today
     * @type {number}
     * @memberof ProjectStatsDto
     */
    'projectsCreatedToday': number;
    /**
     * Number of projects created this week
     * @type {number}
     * @memberof ProjectStatsDto
     */
    'projectsCreatedThisWeek': number;
    /**
     * Number of projects created this month
     * @type {number}
     * @memberof ProjectStatsDto
     */
    'projectsCreatedThisMonth': number;
}
/**
 * 
 * @export
 * @interface ProjectUsersResponseDto
 */
export interface ProjectUsersResponseDto {
    /**
     * Project information
     * @type {ProjectInfoDto}
     * @memberof ProjectUsersResponseDto
     */
    'project': ProjectInfoDto;
    /**
     * List of users in the project with their roles
     * @type {Array<object>}
     * @memberof ProjectUsersResponseDto
     */
    'users': Array<object>;
    /**
     * Total number of users in the project
     * @type {number}
     * @memberof ProjectUsersResponseDto
     */
    'totalUsers': number;
}
/**
 * 
 * @export
 * @interface ProjectsControllerCreate200Response
 */
export interface ProjectsControllerCreate200Response {
    /**
     * Indicates if the request was successful
     * @type {boolean}
     * @memberof ProjectsControllerCreate200Response
     */
    'success': boolean;
    /**
     * 
     * @type {ProjectDto}
     * @memberof ProjectsControllerCreate200Response
     */
    'data': ProjectDto;
    /**
     * Optional message
     * @type {string}
     * @memberof ProjectsControllerCreate200Response
     */
    'message'?: string;
    /**
     * Timestamp of the response
     * @type {string}
     * @memberof ProjectsControllerCreate200Response
     */
    'timestamp': string;
    /**
     * Request path
     * @type {string}
     * @memberof ProjectsControllerCreate200Response
     */
    'path': string;
}
/**
 * 
 * @export
 * @interface ProjectsControllerFindPaginated200Response
 */
export interface ProjectsControllerFindPaginated200Response {
    /**
     * Indicates if the request was successful
     * @type {boolean}
     * @memberof ProjectsControllerFindPaginated200Response
     */
    'success': boolean;
    /**
     * 
     * @type {ProjectsControllerFindPaginated200ResponseAllOfData}
     * @memberof ProjectsControllerFindPaginated200Response
     */
    'data': ProjectsControllerFindPaginated200ResponseAllOfData;
    /**
     * Optional message
     * @type {string}
     * @memberof ProjectsControllerFindPaginated200Response
     */
    'message'?: string;
    /**
     * Timestamp of the response
     * @type {string}
     * @memberof ProjectsControllerFindPaginated200Response
     */
    'timestamp': string;
    /**
     * Request path
     * @type {string}
     * @memberof ProjectsControllerFindPaginated200Response
     */
    'path': string;
}
/**
 * 
 * @export
 * @interface ProjectsControllerFindPaginated200ResponseAllOfData
 */
export interface ProjectsControllerFindPaginated200ResponseAllOfData {
    /**
     * 
     * @type {Array<ProjectDto>}
     * @memberof ProjectsControllerFindPaginated200ResponseAllOfData
     */
    'items'?: Array<ProjectDto>;
}
/**
 * 
 * @export
 * @interface ProjectsControllerGetStats200Response
 */
export interface ProjectsControllerGetStats200Response {
    /**
     * Indicates if the request was successful
     * @type {boolean}
     * @memberof ProjectsControllerGetStats200Response
     */
    'success': boolean;
    /**
     * 
     * @type {ProjectStatsDto}
     * @memberof ProjectsControllerGetStats200Response
     */
    'data': ProjectStatsDto;
    /**
     * Optional message
     * @type {string}
     * @memberof ProjectsControllerGetStats200Response
     */
    'message'?: string;
    /**
     * Timestamp of the response
     * @type {string}
     * @memberof ProjectsControllerGetStats200Response
     */
    'timestamp': string;
    /**
     * Request path
     * @type {string}
     * @memberof ProjectsControllerGetStats200Response
     */
    'path': string;
}
/**
 * 
 * @export
 * @interface RoleDetailsDto
 */
export interface RoleDetailsDto {
    /**
     * Unique identifier of the role
     * @type {string}
     * @memberof RoleDetailsDto
     */
    'id': string;
    /**
     * System name of the role
     * @type {string}
     * @memberof RoleDetailsDto
     */
    'name': string;
    /**
     * Human-readable name of the role
     * @type {string}
     * @memberof RoleDetailsDto
     */
    'displayName': string;
    /**
     * Description of the role and its purpose
     * @type {object}
     * @memberof RoleDetailsDto
     */
    'description'?: object | null;
    /**
     * Whether this is a system-defined role
     * @type {boolean}
     * @memberof RoleDetailsDto
     */
    'isSystem': boolean;
    /**
     * List of all permissions granted by this role
     * @type {Array<PermissionDto>}
     * @memberof RoleDetailsDto
     */
    'permissions': Array<PermissionDto>;
    /**
     * Permissions grouped by resource for easy visualization
     * @type {{ [key: string]: Array<PermissionDto>; }}
     * @memberof RoleDetailsDto
     */
    'permissionsByResource': { [key: string]: Array<PermissionDto>; };
    /**
     * Total number of permissions this role grants
     * @type {number}
     * @memberof RoleDetailsDto
     */
    'totalPermissions': number;
    /**
     * Total number of users assigned this role across all projects
     * @type {number}
     * @memberof RoleDetailsDto
     */
    'totalUsers': number;
}
/**
 * 
 * @export
 * @interface RoleDto
 */
export interface RoleDto {
    /**
     * Unique identifier of the role
     * @type {string}
     * @memberof RoleDto
     */
    'id': string;
    /**
     * System name of the role
     * @type {string}
     * @memberof RoleDto
     */
    'name': string;
    /**
     * Human-readable name of the role
     * @type {string}
     * @memberof RoleDto
     */
    'displayName': string;
    /**
     * Description of the role and its purpose
     * @type {object}
     * @memberof RoleDto
     */
    'description'?: object;
    /**
     * List of permissions granted by this role
     * @type {Array<string>}
     * @memberof RoleDto
     */
    'permissions': Array<string>;
    /**
     * Number of users currently assigned this role
     * @type {number}
     * @memberof RoleDto
     */
    'userCount': number;
}
/**
 * 
 * @export
 * @interface UpdateLocationDto
 */
export interface UpdateLocationDto {
    /**
     * Location name
     * @type {string}
     * @memberof UpdateLocationDto
     */
    'name'?: string;
}
/**
 * 
 * @export
 * @interface UpdateProjectDto
 */
export interface UpdateProjectDto {
    /**
     * Project name
     * @type {string}
     * @memberof UpdateProjectDto
     */
    'name'?: string;
    /**
     * User ID who owns this project
     * @type {object}
     * @memberof UpdateProjectDto
     */
    'userId'?: object;
}
/**
 * 
 * @export
 * @interface UpdateUserDto
 */
export interface UpdateUserDto {
    /**
     * 
     * @type {string}
     * @memberof UpdateUserDto
     */
    'email'?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateUserDto
     */
    'name'?: string;
}
/**
 * 
 * @export
 * @interface UserAssignmentDto
 */
export interface UserAssignmentDto {
    /**
     * User ID to assign the role to
     * @type {string}
     * @memberof UserAssignmentDto
     */
    'userId': string;
}
/**
 * 
 * @export
 * @interface UserDto
 */
export interface UserDto {
    /**
     * User ID
     * @type {number}
     * @memberof UserDto
     */
    'id': number;
    /**
     * User email address
     * @type {string}
     * @memberof UserDto
     */
    'email': string;
    /**
     * User full name
     * @type {string}
     * @memberof UserDto
     */
    'name': string;
    /**
     * User creation timestamp
     * @type {string}
     * @memberof UserDto
     */
    'createdAt': string;
    /**
     * User last update timestamp
     * @type {string}
     * @memberof UserDto
     */
    'updatedAt': string;
}
/**
 * 
 * @export
 * @interface UserInfoDto
 */
export interface UserInfoDto {
    /**
     * User ID
     * @type {string}
     * @memberof UserInfoDto
     */
    'id': string;
    /**
     * User email address
     * @type {string}
     * @memberof UserInfoDto
     */
    'email': string;
    /**
     * User full name
     * @type {string}
     * @memberof UserInfoDto
     */
    'name': string;
}
/**
 * 
 * @export
 * @interface UserStatsDto
 */
export interface UserStatsDto {
    /**
     * Total number of users
     * @type {number}
     * @memberof UserStatsDto
     */
    'totalUsers': number;
    /**
     * Number of users with at least one project
     * @type {number}
     * @memberof UserStatsDto
     */
    'usersWithProjects': number;
    /**
     * Average number of projects per user
     * @type {number}
     * @memberof UserStatsDto
     */
    'averageProjectsPerUser': number;
    /**
     * Number of users created in the last 30 days
     * @type {number}
     * @memberof UserStatsDto
     */
    'recentUsers': number;
}
/**
 * 
 * @export
 * @interface UserWithRolesDto
 */
export interface UserWithRolesDto {
    /**
     * User information
     * @type {UserInfoDto}
     * @memberof UserWithRolesDto
     */
    'user': UserInfoDto;
    /**
     * List of roles assigned to the user in this project
     * @type {Array<object>}
     * @memberof UserWithRolesDto
     */
    'roles': Array<object>;
    /**
     * Total number of roles assigned to the user
     * @type {number}
     * @memberof UserWithRolesDto
     */
    'totalRoles': number;
}
/**
 * 
 * @export
 * @interface UsersControllerCreate200Response
 */
export interface UsersControllerCreate200Response {
    /**
     * Indicates if the request was successful
     * @type {boolean}
     * @memberof UsersControllerCreate200Response
     */
    'success': boolean;
    /**
     * 
     * @type {UserDto}
     * @memberof UsersControllerCreate200Response
     */
    'data': UserDto;
    /**
     * Optional message
     * @type {string}
     * @memberof UsersControllerCreate200Response
     */
    'message'?: string;
    /**
     * Timestamp of the response
     * @type {string}
     * @memberof UsersControllerCreate200Response
     */
    'timestamp': string;
    /**
     * Request path
     * @type {string}
     * @memberof UsersControllerCreate200Response
     */
    'path': string;
}
/**
 * 
 * @export
 * @interface UsersControllerFindPaginated200Response
 */
export interface UsersControllerFindPaginated200Response {
    /**
     * Indicates if the request was successful
     * @type {boolean}
     * @memberof UsersControllerFindPaginated200Response
     */
    'success': boolean;
    /**
     * 
     * @type {UsersControllerFindPaginated200ResponseAllOfData}
     * @memberof UsersControllerFindPaginated200Response
     */
    'data': UsersControllerFindPaginated200ResponseAllOfData;
    /**
     * Optional message
     * @type {string}
     * @memberof UsersControllerFindPaginated200Response
     */
    'message'?: string;
    /**
     * Timestamp of the response
     * @type {string}
     * @memberof UsersControllerFindPaginated200Response
     */
    'timestamp': string;
    /**
     * Request path
     * @type {string}
     * @memberof UsersControllerFindPaginated200Response
     */
    'path': string;
}
/**
 * 
 * @export
 * @interface UsersControllerFindPaginated200ResponseAllOfData
 */
export interface UsersControllerFindPaginated200ResponseAllOfData {
    /**
     * 
     * @type {Array<UserDto>}
     * @memberof UsersControllerFindPaginated200ResponseAllOfData
     */
    'items'?: Array<UserDto>;
}
/**
 * 
 * @export
 * @interface UsersControllerGetStats200Response
 */
export interface UsersControllerGetStats200Response {
    /**
     * Indicates if the request was successful
     * @type {boolean}
     * @memberof UsersControllerGetStats200Response
     */
    'success': boolean;
    /**
     * 
     * @type {UserStatsDto}
     * @memberof UsersControllerGetStats200Response
     */
    'data': UserStatsDto;
    /**
     * Optional message
     * @type {string}
     * @memberof UsersControllerGetStats200Response
     */
    'message'?: string;
    /**
     * Timestamp of the response
     * @type {string}
     * @memberof UsersControllerGetStats200Response
     */
    'timestamp': string;
    /**
     * Request path
     * @type {string}
     * @memberof UsersControllerGetStats200Response
     */
    'path': string;
}

/**
 * AuthenticationApi - axios parameter creator
 * @export
 */
export const AuthenticationApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get current user profile from JWT
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authControllerGetProfile: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/auth/profile`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get current token metadata
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authControllerGetTokenInfo: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/auth/token-info`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Login with email and password
         * @param {object} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authControllerLogin: async (body: object, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            assertParamExists('authControllerLogin', 'body', body)
            const localVarPath = `/auth/login`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Switch to a different project context
         * @param {object} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authControllerSwitchProject: async (body: object, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            assertParamExists('authControllerSwitchProject', 'body', body)
            const localVarPath = `/auth/switch-project`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AuthenticationApi - functional programming interface
 * @export
 */
export const AuthenticationApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AuthenticationApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Get current user profile from JWT
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authControllerGetProfile(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AuthControllerGetProfile200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authControllerGetProfile(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthenticationApi.authControllerGetProfile']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get current token metadata
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authControllerGetTokenInfo(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authControllerGetTokenInfo(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthenticationApi.authControllerGetTokenInfo']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Login with email and password
         * @param {object} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authControllerLogin(body: object, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AuthControllerLogin200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authControllerLogin(body, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthenticationApi.authControllerLogin']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Switch to a different project context
         * @param {object} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authControllerSwitchProject(body: object, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AuthControllerLogin200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authControllerSwitchProject(body, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthenticationApi.authControllerSwitchProject']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * AuthenticationApi - factory interface
 * @export
 */
export const AuthenticationApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AuthenticationApiFp(configuration)
    return {
        /**
         * 
         * @summary Get current user profile from JWT
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authControllerGetProfile(options?: RawAxiosRequestConfig): AxiosPromise<AuthControllerGetProfile200Response> {
            return localVarFp.authControllerGetProfile(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get current token metadata
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authControllerGetTokenInfo(options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.authControllerGetTokenInfo(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Login with email and password
         * @param {object} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authControllerLogin(body: object, options?: RawAxiosRequestConfig): AxiosPromise<AuthControllerLogin200Response> {
            return localVarFp.authControllerLogin(body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Switch to a different project context
         * @param {object} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authControllerSwitchProject(body: object, options?: RawAxiosRequestConfig): AxiosPromise<AuthControllerLogin200Response> {
            return localVarFp.authControllerSwitchProject(body, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AuthenticationApi - interface
 * @export
 * @interface AuthenticationApi
 */
export interface AuthenticationApiInterface {
    /**
     * 
     * @summary Get current user profile from JWT
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthenticationApiInterface
     */
    authControllerGetProfile(options?: RawAxiosRequestConfig): AxiosPromise<AuthControllerGetProfile200Response>;

    /**
     * 
     * @summary Get current token metadata
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthenticationApiInterface
     */
    authControllerGetTokenInfo(options?: RawAxiosRequestConfig): AxiosPromise<void>;

    /**
     * 
     * @summary Login with email and password
     * @param {object} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthenticationApiInterface
     */
    authControllerLogin(body: object, options?: RawAxiosRequestConfig): AxiosPromise<AuthControllerLogin200Response>;

    /**
     * 
     * @summary Switch to a different project context
     * @param {object} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthenticationApiInterface
     */
    authControllerSwitchProject(body: object, options?: RawAxiosRequestConfig): AxiosPromise<AuthControllerLogin200Response>;

}

/**
 * AuthenticationApi - object-oriented interface
 * @export
 * @class AuthenticationApi
 * @extends {BaseAPI}
 */
export class AuthenticationApi extends BaseAPI implements AuthenticationApiInterface {
    /**
     * 
     * @summary Get current user profile from JWT
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthenticationApi
     */
    public authControllerGetProfile(options?: RawAxiosRequestConfig) {
        return AuthenticationApiFp(this.configuration).authControllerGetProfile(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get current token metadata
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthenticationApi
     */
    public authControllerGetTokenInfo(options?: RawAxiosRequestConfig) {
        return AuthenticationApiFp(this.configuration).authControllerGetTokenInfo(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Login with email and password
     * @param {object} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthenticationApi
     */
    public authControllerLogin(body: object, options?: RawAxiosRequestConfig) {
        return AuthenticationApiFp(this.configuration).authControllerLogin(body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Switch to a different project context
     * @param {object} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthenticationApi
     */
    public authControllerSwitchProject(body: object, options?: RawAxiosRequestConfig) {
        return AuthenticationApiFp(this.configuration).authControllerSwitchProject(body, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * HealthApi - axios parameter creator
 * @export
 */
export const HealthApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Health check endpoint
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        healthControllerCheck: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/health`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Export audit logs
         * @param {number} [limit] Number of records to return (default: 100)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        healthControllerExportAuditLogs: async (limit?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/health/audit/export`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * HealthApi - functional programming interface
 * @export
 */
export const HealthApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = HealthApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Health check endpoint
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async healthControllerCheck(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<HealthControllerCheck200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.healthControllerCheck(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['HealthApi.healthControllerCheck']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Export audit logs
         * @param {number} [limit] Number of records to return (default: 100)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async healthControllerExportAuditLogs(limit?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<HealthControllerExportAuditLogs200ResponseInner>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.healthControllerExportAuditLogs(limit, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['HealthApi.healthControllerExportAuditLogs']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * HealthApi - factory interface
 * @export
 */
export const HealthApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = HealthApiFp(configuration)
    return {
        /**
         * 
         * @summary Health check endpoint
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        healthControllerCheck(options?: RawAxiosRequestConfig): AxiosPromise<HealthControllerCheck200Response> {
            return localVarFp.healthControllerCheck(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Export audit logs
         * @param {number} [limit] Number of records to return (default: 100)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        healthControllerExportAuditLogs(limit?: number, options?: RawAxiosRequestConfig): AxiosPromise<Array<HealthControllerExportAuditLogs200ResponseInner>> {
            return localVarFp.healthControllerExportAuditLogs(limit, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * HealthApi - interface
 * @export
 * @interface HealthApi
 */
export interface HealthApiInterface {
    /**
     * 
     * @summary Health check endpoint
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HealthApiInterface
     */
    healthControllerCheck(options?: RawAxiosRequestConfig): AxiosPromise<HealthControllerCheck200Response>;

    /**
     * 
     * @summary Export audit logs
     * @param {number} [limit] Number of records to return (default: 100)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HealthApiInterface
     */
    healthControllerExportAuditLogs(limit?: number, options?: RawAxiosRequestConfig): AxiosPromise<Array<HealthControllerExportAuditLogs200ResponseInner>>;

}

/**
 * HealthApi - object-oriented interface
 * @export
 * @class HealthApi
 * @extends {BaseAPI}
 */
export class HealthApi extends BaseAPI implements HealthApiInterface {
    /**
     * 
     * @summary Health check endpoint
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HealthApi
     */
    public healthControllerCheck(options?: RawAxiosRequestConfig) {
        return HealthApiFp(this.configuration).healthControllerCheck(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Export audit logs
     * @param {number} [limit] Number of records to return (default: 100)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HealthApi
     */
    public healthControllerExportAuditLogs(limit?: number, options?: RawAxiosRequestConfig) {
        return HealthApiFp(this.configuration).healthControllerExportAuditLogs(limit, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * LocationsApi - axios parameter creator
 * @export
 */
export const LocationsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Creates a new location within the specified project. Requires create:location permission.
         * @summary Create a new location in a project
         * @param {string} projectId Project ID
         * @param {CreateLocationDto} createLocationDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        locationsControllerCreate: async (projectId: string, createLocationDto: CreateLocationDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('locationsControllerCreate', 'projectId', projectId)
            // verify required parameter 'createLocationDto' is not null or undefined
            assertParamExists('locationsControllerCreate', 'createLocationDto', createLocationDto)
            const localVarPath = `/projects/{projectId}/locations`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createLocationDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns all locations within the specified project. Requires view:location permission.
         * @summary Get all locations in a project (deprecated - use /paginated instead)
         * @param {string} projectId Project ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        locationsControllerFindAll: async (projectId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('locationsControllerFindAll', 'projectId', projectId)
            const localVarPath = `/projects/{projectId}/locations`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a specific location by ID within the specified project. Requires view:location permission.
         * @summary Get location by id
         * @param {string} projectId Project ID
         * @param {string} id Location ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        locationsControllerFindOne: async (projectId: string, id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('locationsControllerFindOne', 'projectId', projectId)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('locationsControllerFindOne', 'id', id)
            const localVarPath = `/projects/{projectId}/locations/{id}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns paginated locations within the specified project with optional search and sorting. Requires view:location permission.
         * @summary Get paginated locations with search and sort
         * @param {string} projectId Project ID
         * @param {number} [page] Page number for pagination
         * @param {number} [limit] Number of items per page
         * @param {string} [search] Search term to filter locations by name
         * @param {LocationsControllerFindPaginatedSortByEnum} [sortBy] Sort field
         * @param {LocationsControllerFindPaginatedSortOrderEnum} [sortOrder] Sort order
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        locationsControllerFindPaginated: async (projectId: string, page?: number, limit?: number, search?: string, sortBy?: LocationsControllerFindPaginatedSortByEnum, sortOrder?: LocationsControllerFindPaginatedSortOrderEnum, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('locationsControllerFindPaginated', 'projectId', projectId)
            const localVarPath = `/projects/{projectId}/locations/paginated`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sortBy'] = sortBy;
            }

            if (sortOrder !== undefined) {
                localVarQueryParameter['sortOrder'] = sortOrder;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Deletes a location by ID within the specified project. Requires delete:location permission.
         * @summary Delete location
         * @param {string} projectId Project ID
         * @param {string} id Location ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        locationsControllerRemove: async (projectId: string, id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('locationsControllerRemove', 'projectId', projectId)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('locationsControllerRemove', 'id', id)
            const localVarPath = `/projects/{projectId}/locations/{id}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates a location by ID within the specified project. Requires edit:location permission.
         * @summary Update location
         * @param {string} projectId Project ID
         * @param {string} id Location ID
         * @param {UpdateLocationDto} updateLocationDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        locationsControllerUpdate: async (projectId: string, id: string, updateLocationDto: UpdateLocationDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('locationsControllerUpdate', 'projectId', projectId)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('locationsControllerUpdate', 'id', id)
            // verify required parameter 'updateLocationDto' is not null or undefined
            assertParamExists('locationsControllerUpdate', 'updateLocationDto', updateLocationDto)
            const localVarPath = `/projects/{projectId}/locations/{id}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateLocationDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * LocationsApi - functional programming interface
 * @export
 */
export const LocationsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = LocationsApiAxiosParamCreator(configuration)
    return {
        /**
         * Creates a new location within the specified project. Requires create:location permission.
         * @summary Create a new location in a project
         * @param {string} projectId Project ID
         * @param {CreateLocationDto} createLocationDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async locationsControllerCreate(projectId: string, createLocationDto: CreateLocationDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LocationsControllerCreate200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.locationsControllerCreate(projectId, createLocationDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['LocationsApi.locationsControllerCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns all locations within the specified project. Requires view:location permission.
         * @summary Get all locations in a project (deprecated - use /paginated instead)
         * @param {string} projectId Project ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async locationsControllerFindAll(projectId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.locationsControllerFindAll(projectId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['LocationsApi.locationsControllerFindAll']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns a specific location by ID within the specified project. Requires view:location permission.
         * @summary Get location by id
         * @param {string} projectId Project ID
         * @param {string} id Location ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async locationsControllerFindOne(projectId: string, id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.locationsControllerFindOne(projectId, id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['LocationsApi.locationsControllerFindOne']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns paginated locations within the specified project with optional search and sorting. Requires view:location permission.
         * @summary Get paginated locations with search and sort
         * @param {string} projectId Project ID
         * @param {number} [page] Page number for pagination
         * @param {number} [limit] Number of items per page
         * @param {string} [search] Search term to filter locations by name
         * @param {LocationsControllerFindPaginatedSortByEnum} [sortBy] Sort field
         * @param {LocationsControllerFindPaginatedSortOrderEnum} [sortOrder] Sort order
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async locationsControllerFindPaginated(projectId: string, page?: number, limit?: number, search?: string, sortBy?: LocationsControllerFindPaginatedSortByEnum, sortOrder?: LocationsControllerFindPaginatedSortOrderEnum, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LocationsControllerFindPaginated200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.locationsControllerFindPaginated(projectId, page, limit, search, sortBy, sortOrder, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['LocationsApi.locationsControllerFindPaginated']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Deletes a location by ID within the specified project. Requires delete:location permission.
         * @summary Delete location
         * @param {string} projectId Project ID
         * @param {string} id Location ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async locationsControllerRemove(projectId: string, id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.locationsControllerRemove(projectId, id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['LocationsApi.locationsControllerRemove']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Updates a location by ID within the specified project. Requires edit:location permission.
         * @summary Update location
         * @param {string} projectId Project ID
         * @param {string} id Location ID
         * @param {UpdateLocationDto} updateLocationDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async locationsControllerUpdate(projectId: string, id: string, updateLocationDto: UpdateLocationDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.locationsControllerUpdate(projectId, id, updateLocationDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['LocationsApi.locationsControllerUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * LocationsApi - factory interface
 * @export
 */
export const LocationsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = LocationsApiFp(configuration)
    return {
        /**
         * Creates a new location within the specified project. Requires create:location permission.
         * @summary Create a new location in a project
         * @param {string} projectId Project ID
         * @param {CreateLocationDto} createLocationDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        locationsControllerCreate(projectId: string, createLocationDto: CreateLocationDto, options?: RawAxiosRequestConfig): AxiosPromise<LocationsControllerCreate200Response> {
            return localVarFp.locationsControllerCreate(projectId, createLocationDto, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns all locations within the specified project. Requires view:location permission.
         * @summary Get all locations in a project (deprecated - use /paginated instead)
         * @param {string} projectId Project ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        locationsControllerFindAll(projectId: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.locationsControllerFindAll(projectId, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a specific location by ID within the specified project. Requires view:location permission.
         * @summary Get location by id
         * @param {string} projectId Project ID
         * @param {string} id Location ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        locationsControllerFindOne(projectId: string, id: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.locationsControllerFindOne(projectId, id, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns paginated locations within the specified project with optional search and sorting. Requires view:location permission.
         * @summary Get paginated locations with search and sort
         * @param {string} projectId Project ID
         * @param {number} [page] Page number for pagination
         * @param {number} [limit] Number of items per page
         * @param {string} [search] Search term to filter locations by name
         * @param {LocationsControllerFindPaginatedSortByEnum} [sortBy] Sort field
         * @param {LocationsControllerFindPaginatedSortOrderEnum} [sortOrder] Sort order
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        locationsControllerFindPaginated(projectId: string, page?: number, limit?: number, search?: string, sortBy?: LocationsControllerFindPaginatedSortByEnum, sortOrder?: LocationsControllerFindPaginatedSortOrderEnum, options?: RawAxiosRequestConfig): AxiosPromise<LocationsControllerFindPaginated200Response> {
            return localVarFp.locationsControllerFindPaginated(projectId, page, limit, search, sortBy, sortOrder, options).then((request) => request(axios, basePath));
        },
        /**
         * Deletes a location by ID within the specified project. Requires delete:location permission.
         * @summary Delete location
         * @param {string} projectId Project ID
         * @param {string} id Location ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        locationsControllerRemove(projectId: string, id: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.locationsControllerRemove(projectId, id, options).then((request) => request(axios, basePath));
        },
        /**
         * Updates a location by ID within the specified project. Requires edit:location permission.
         * @summary Update location
         * @param {string} projectId Project ID
         * @param {string} id Location ID
         * @param {UpdateLocationDto} updateLocationDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        locationsControllerUpdate(projectId: string, id: string, updateLocationDto: UpdateLocationDto, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.locationsControllerUpdate(projectId, id, updateLocationDto, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * LocationsApi - interface
 * @export
 * @interface LocationsApi
 */
export interface LocationsApiInterface {
    /**
     * Creates a new location within the specified project. Requires create:location permission.
     * @summary Create a new location in a project
     * @param {string} projectId Project ID
     * @param {CreateLocationDto} createLocationDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LocationsApiInterface
     */
    locationsControllerCreate(projectId: string, createLocationDto: CreateLocationDto, options?: RawAxiosRequestConfig): AxiosPromise<LocationsControllerCreate200Response>;

    /**
     * Returns all locations within the specified project. Requires view:location permission.
     * @summary Get all locations in a project (deprecated - use /paginated instead)
     * @param {string} projectId Project ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LocationsApiInterface
     */
    locationsControllerFindAll(projectId: string, options?: RawAxiosRequestConfig): AxiosPromise<void>;

    /**
     * Returns a specific location by ID within the specified project. Requires view:location permission.
     * @summary Get location by id
     * @param {string} projectId Project ID
     * @param {string} id Location ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LocationsApiInterface
     */
    locationsControllerFindOne(projectId: string, id: string, options?: RawAxiosRequestConfig): AxiosPromise<void>;

    /**
     * Returns paginated locations within the specified project with optional search and sorting. Requires view:location permission.
     * @summary Get paginated locations with search and sort
     * @param {string} projectId Project ID
     * @param {number} [page] Page number for pagination
     * @param {number} [limit] Number of items per page
     * @param {string} [search] Search term to filter locations by name
     * @param {LocationsControllerFindPaginatedSortByEnum} [sortBy] Sort field
     * @param {LocationsControllerFindPaginatedSortOrderEnum} [sortOrder] Sort order
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LocationsApiInterface
     */
    locationsControllerFindPaginated(projectId: string, page?: number, limit?: number, search?: string, sortBy?: LocationsControllerFindPaginatedSortByEnum, sortOrder?: LocationsControllerFindPaginatedSortOrderEnum, options?: RawAxiosRequestConfig): AxiosPromise<LocationsControllerFindPaginated200Response>;

    /**
     * Deletes a location by ID within the specified project. Requires delete:location permission.
     * @summary Delete location
     * @param {string} projectId Project ID
     * @param {string} id Location ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LocationsApiInterface
     */
    locationsControllerRemove(projectId: string, id: string, options?: RawAxiosRequestConfig): AxiosPromise<void>;

    /**
     * Updates a location by ID within the specified project. Requires edit:location permission.
     * @summary Update location
     * @param {string} projectId Project ID
     * @param {string} id Location ID
     * @param {UpdateLocationDto} updateLocationDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LocationsApiInterface
     */
    locationsControllerUpdate(projectId: string, id: string, updateLocationDto: UpdateLocationDto, options?: RawAxiosRequestConfig): AxiosPromise<void>;

}

/**
 * LocationsApi - object-oriented interface
 * @export
 * @class LocationsApi
 * @extends {BaseAPI}
 */
export class LocationsApi extends BaseAPI implements LocationsApiInterface {
    /**
     * Creates a new location within the specified project. Requires create:location permission.
     * @summary Create a new location in a project
     * @param {string} projectId Project ID
     * @param {CreateLocationDto} createLocationDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LocationsApi
     */
    public locationsControllerCreate(projectId: string, createLocationDto: CreateLocationDto, options?: RawAxiosRequestConfig) {
        return LocationsApiFp(this.configuration).locationsControllerCreate(projectId, createLocationDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns all locations within the specified project. Requires view:location permission.
     * @summary Get all locations in a project (deprecated - use /paginated instead)
     * @param {string} projectId Project ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LocationsApi
     */
    public locationsControllerFindAll(projectId: string, options?: RawAxiosRequestConfig) {
        return LocationsApiFp(this.configuration).locationsControllerFindAll(projectId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a specific location by ID within the specified project. Requires view:location permission.
     * @summary Get location by id
     * @param {string} projectId Project ID
     * @param {string} id Location ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LocationsApi
     */
    public locationsControllerFindOne(projectId: string, id: string, options?: RawAxiosRequestConfig) {
        return LocationsApiFp(this.configuration).locationsControllerFindOne(projectId, id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns paginated locations within the specified project with optional search and sorting. Requires view:location permission.
     * @summary Get paginated locations with search and sort
     * @param {string} projectId Project ID
     * @param {number} [page] Page number for pagination
     * @param {number} [limit] Number of items per page
     * @param {string} [search] Search term to filter locations by name
     * @param {LocationsControllerFindPaginatedSortByEnum} [sortBy] Sort field
     * @param {LocationsControllerFindPaginatedSortOrderEnum} [sortOrder] Sort order
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LocationsApi
     */
    public locationsControllerFindPaginated(projectId: string, page?: number, limit?: number, search?: string, sortBy?: LocationsControllerFindPaginatedSortByEnum, sortOrder?: LocationsControllerFindPaginatedSortOrderEnum, options?: RawAxiosRequestConfig) {
        return LocationsApiFp(this.configuration).locationsControllerFindPaginated(projectId, page, limit, search, sortBy, sortOrder, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Deletes a location by ID within the specified project. Requires delete:location permission.
     * @summary Delete location
     * @param {string} projectId Project ID
     * @param {string} id Location ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LocationsApi
     */
    public locationsControllerRemove(projectId: string, id: string, options?: RawAxiosRequestConfig) {
        return LocationsApiFp(this.configuration).locationsControllerRemove(projectId, id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Updates a location by ID within the specified project. Requires edit:location permission.
     * @summary Update location
     * @param {string} projectId Project ID
     * @param {string} id Location ID
     * @param {UpdateLocationDto} updateLocationDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LocationsApi
     */
    public locationsControllerUpdate(projectId: string, id: string, updateLocationDto: UpdateLocationDto, options?: RawAxiosRequestConfig) {
        return LocationsApiFp(this.configuration).locationsControllerUpdate(projectId, id, updateLocationDto, options).then((request) => request(this.axios, this.basePath));
    }
}

/**
  * @export
  * @enum {string}
  */
export enum LocationsControllerFindPaginatedSortByEnum {
    Name = 'name',
    Id = 'id'
}
/**
  * @export
  * @enum {string}
  */
export enum LocationsControllerFindPaginatedSortOrderEnum {
    Asc = 'asc',
    Desc = 'desc'
}


/**
 * PermissionsApi - axios parameter creator
 * @export
 */
export const PermissionsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Check if the current user has a specific permission in their active project.
         * @summary Check specific permission
         * @param {string} permission Permission to check (e.g., \&quot;edit:asset\&quot;)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        permissionsControllerCheckPermission: async (permission: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'permission' is not null or undefined
            assertParamExists('permissionsControllerCheckPermission', 'permission', permission)
            const localVarPath = `/permissions/check/{permission}`
                .replace(`{${"permission"}}`, encodeURIComponent(String(permission)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get the current user\'s permissions in their active project context.
         * @summary Get my permissions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        permissionsControllerGetMyPermissions: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/permissions/my-permissions`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a matrix showing all roles and their permissions for easy visualization.
         * @summary Get permission matrix
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        permissionsControllerGetPermissionMatrix: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/permissions/matrix`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get detailed information about a specific role including all its permissions.
         * @summary Get role details
         * @param {string} roleName Role name (e.g., \&quot;project_admin\&quot;)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        permissionsControllerGetRoleDetails: async (roleName: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'roleName' is not null or undefined
            assertParamExists('permissionsControllerGetRoleDetails', 'roleName', roleName)
            const localVarPath = `/permissions/roles/{roleName}`
                .replace(`{${"roleName"}}`, encodeURIComponent(String(roleName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get all available permissions in the system grouped by resource.
         * @summary List all permissions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        permissionsControllerListAllPermissions: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/permissions`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PermissionsApi - functional programming interface
 * @export
 */
export const PermissionsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = PermissionsApiAxiosParamCreator(configuration)
    return {
        /**
         * Check if the current user has a specific permission in their active project.
         * @summary Check specific permission
         * @param {string} permission Permission to check (e.g., \&quot;edit:asset\&quot;)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async permissionsControllerCheckPermission(permission: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PermissionCheckResultDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.permissionsControllerCheckPermission(permission, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PermissionsApi.permissionsControllerCheckPermission']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get the current user\'s permissions in their active project context.
         * @summary Get my permissions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async permissionsControllerGetMyPermissions(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MyPermissionsDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.permissionsControllerGetMyPermissions(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PermissionsApi.permissionsControllerGetMyPermissions']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get a matrix showing all roles and their permissions for easy visualization.
         * @summary Get permission matrix
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async permissionsControllerGetPermissionMatrix(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PermissionMatrixDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.permissionsControllerGetPermissionMatrix(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PermissionsApi.permissionsControllerGetPermissionMatrix']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get detailed information about a specific role including all its permissions.
         * @summary Get role details
         * @param {string} roleName Role name (e.g., \&quot;project_admin\&quot;)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async permissionsControllerGetRoleDetails(roleName: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RoleDetailsDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.permissionsControllerGetRoleDetails(roleName, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PermissionsApi.permissionsControllerGetRoleDetails']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get all available permissions in the system grouped by resource.
         * @summary List all permissions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async permissionsControllerListAllPermissions(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<PermissionDto>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.permissionsControllerListAllPermissions(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PermissionsApi.permissionsControllerListAllPermissions']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * PermissionsApi - factory interface
 * @export
 */
export const PermissionsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = PermissionsApiFp(configuration)
    return {
        /**
         * Check if the current user has a specific permission in their active project.
         * @summary Check specific permission
         * @param {string} permission Permission to check (e.g., \&quot;edit:asset\&quot;)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        permissionsControllerCheckPermission(permission: string, options?: RawAxiosRequestConfig): AxiosPromise<PermissionCheckResultDto> {
            return localVarFp.permissionsControllerCheckPermission(permission, options).then((request) => request(axios, basePath));
        },
        /**
         * Get the current user\'s permissions in their active project context.
         * @summary Get my permissions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        permissionsControllerGetMyPermissions(options?: RawAxiosRequestConfig): AxiosPromise<MyPermissionsDto> {
            return localVarFp.permissionsControllerGetMyPermissions(options).then((request) => request(axios, basePath));
        },
        /**
         * Get a matrix showing all roles and their permissions for easy visualization.
         * @summary Get permission matrix
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        permissionsControllerGetPermissionMatrix(options?: RawAxiosRequestConfig): AxiosPromise<PermissionMatrixDto> {
            return localVarFp.permissionsControllerGetPermissionMatrix(options).then((request) => request(axios, basePath));
        },
        /**
         * Get detailed information about a specific role including all its permissions.
         * @summary Get role details
         * @param {string} roleName Role name (e.g., \&quot;project_admin\&quot;)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        permissionsControllerGetRoleDetails(roleName: string, options?: RawAxiosRequestConfig): AxiosPromise<RoleDetailsDto> {
            return localVarFp.permissionsControllerGetRoleDetails(roleName, options).then((request) => request(axios, basePath));
        },
        /**
         * Get all available permissions in the system grouped by resource.
         * @summary List all permissions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        permissionsControllerListAllPermissions(options?: RawAxiosRequestConfig): AxiosPromise<Array<PermissionDto>> {
            return localVarFp.permissionsControllerListAllPermissions(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * PermissionsApi - interface
 * @export
 * @interface PermissionsApi
 */
export interface PermissionsApiInterface {
    /**
     * Check if the current user has a specific permission in their active project.
     * @summary Check specific permission
     * @param {string} permission Permission to check (e.g., \&quot;edit:asset\&quot;)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PermissionsApiInterface
     */
    permissionsControllerCheckPermission(permission: string, options?: RawAxiosRequestConfig): AxiosPromise<PermissionCheckResultDto>;

    /**
     * Get the current user\'s permissions in their active project context.
     * @summary Get my permissions
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PermissionsApiInterface
     */
    permissionsControllerGetMyPermissions(options?: RawAxiosRequestConfig): AxiosPromise<MyPermissionsDto>;

    /**
     * Get a matrix showing all roles and their permissions for easy visualization.
     * @summary Get permission matrix
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PermissionsApiInterface
     */
    permissionsControllerGetPermissionMatrix(options?: RawAxiosRequestConfig): AxiosPromise<PermissionMatrixDto>;

    /**
     * Get detailed information about a specific role including all its permissions.
     * @summary Get role details
     * @param {string} roleName Role name (e.g., \&quot;project_admin\&quot;)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PermissionsApiInterface
     */
    permissionsControllerGetRoleDetails(roleName: string, options?: RawAxiosRequestConfig): AxiosPromise<RoleDetailsDto>;

    /**
     * Get all available permissions in the system grouped by resource.
     * @summary List all permissions
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PermissionsApiInterface
     */
    permissionsControllerListAllPermissions(options?: RawAxiosRequestConfig): AxiosPromise<Array<PermissionDto>>;

}

/**
 * PermissionsApi - object-oriented interface
 * @export
 * @class PermissionsApi
 * @extends {BaseAPI}
 */
export class PermissionsApi extends BaseAPI implements PermissionsApiInterface {
    /**
     * Check if the current user has a specific permission in their active project.
     * @summary Check specific permission
     * @param {string} permission Permission to check (e.g., \&quot;edit:asset\&quot;)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PermissionsApi
     */
    public permissionsControllerCheckPermission(permission: string, options?: RawAxiosRequestConfig) {
        return PermissionsApiFp(this.configuration).permissionsControllerCheckPermission(permission, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get the current user\'s permissions in their active project context.
     * @summary Get my permissions
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PermissionsApi
     */
    public permissionsControllerGetMyPermissions(options?: RawAxiosRequestConfig) {
        return PermissionsApiFp(this.configuration).permissionsControllerGetMyPermissions(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a matrix showing all roles and their permissions for easy visualization.
     * @summary Get permission matrix
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PermissionsApi
     */
    public permissionsControllerGetPermissionMatrix(options?: RawAxiosRequestConfig) {
        return PermissionsApiFp(this.configuration).permissionsControllerGetPermissionMatrix(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get detailed information about a specific role including all its permissions.
     * @summary Get role details
     * @param {string} roleName Role name (e.g., \&quot;project_admin\&quot;)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PermissionsApi
     */
    public permissionsControllerGetRoleDetails(roleName: string, options?: RawAxiosRequestConfig) {
        return PermissionsApiFp(this.configuration).permissionsControllerGetRoleDetails(roleName, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get all available permissions in the system grouped by resource.
     * @summary List all permissions
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PermissionsApi
     */
    public permissionsControllerListAllPermissions(options?: RawAxiosRequestConfig) {
        return PermissionsApiFp(this.configuration).permissionsControllerListAllPermissions(options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ProjectsApi - axios parameter creator
 * @export
 */
export const ProjectsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Creates a new project. Requires create:project permission.
         * @summary Create a new project
         * @param {CreateProjectDto} createProjectDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectsControllerCreate: async (createProjectDto: CreateProjectDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createProjectDto' is not null or undefined
            assertParamExists('projectsControllerCreate', 'createProjectDto', createProjectDto)
            const localVarPath = `/projects`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createProjectDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns all projects. Requires view:project permission.
         * @summary Get all projects (deprecated - use /projects/paginated instead)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectsControllerFindAll: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/projects`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a specific project by ID. Requires view:project permission.
         * @summary Get project by id
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectsControllerFindOne: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('projectsControllerFindOne', 'id', id)
            const localVarPath = `/projects/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns paginated projects with optional search and sorting. Requires view:project permission.
         * @summary Get paginated projects with search and sort
         * @param {number} [page] Page number for pagination
         * @param {number} [limit] Number of items per page
         * @param {string} [search] Search term to filter projects by name
         * @param {ProjectsControllerFindPaginatedSortByEnum} [sortBy] Sort field
         * @param {ProjectsControllerFindPaginatedSortOrderEnum} [sortOrder] Sort order
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectsControllerFindPaginated: async (page?: number, limit?: number, search?: string, sortBy?: ProjectsControllerFindPaginatedSortByEnum, sortOrder?: ProjectsControllerFindPaginatedSortOrderEnum, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/projects/paginated`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sortBy'] = sortBy;
            }

            if (sortOrder !== undefined) {
                localVarQueryParameter['sortOrder'] = sortOrder;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns project statistics including counts and recent activity. Requires view:project permission.
         * @summary Get project statistics
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectsControllerGetStats: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/projects/stats`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Deletes a project by ID. Requires delete:project permission.
         * @summary Delete project
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectsControllerRemove: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('projectsControllerRemove', 'id', id)
            const localVarPath = `/projects/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates a project by ID. Requires edit:project permission.
         * @summary Update project
         * @param {string} id 
         * @param {UpdateProjectDto} updateProjectDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectsControllerUpdate: async (id: string, updateProjectDto: UpdateProjectDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('projectsControllerUpdate', 'id', id)
            // verify required parameter 'updateProjectDto' is not null or undefined
            assertParamExists('projectsControllerUpdate', 'updateProjectDto', updateProjectDto)
            const localVarPath = `/projects/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateProjectDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ProjectsApi - functional programming interface
 * @export
 */
export const ProjectsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ProjectsApiAxiosParamCreator(configuration)
    return {
        /**
         * Creates a new project. Requires create:project permission.
         * @summary Create a new project
         * @param {CreateProjectDto} createProjectDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async projectsControllerCreate(createProjectDto: CreateProjectDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProjectsControllerCreate200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.projectsControllerCreate(createProjectDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProjectsApi.projectsControllerCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns all projects. Requires view:project permission.
         * @summary Get all projects (deprecated - use /projects/paginated instead)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async projectsControllerFindAll(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.projectsControllerFindAll(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProjectsApi.projectsControllerFindAll']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns a specific project by ID. Requires view:project permission.
         * @summary Get project by id
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async projectsControllerFindOne(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.projectsControllerFindOne(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProjectsApi.projectsControllerFindOne']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns paginated projects with optional search and sorting. Requires view:project permission.
         * @summary Get paginated projects with search and sort
         * @param {number} [page] Page number for pagination
         * @param {number} [limit] Number of items per page
         * @param {string} [search] Search term to filter projects by name
         * @param {ProjectsControllerFindPaginatedSortByEnum} [sortBy] Sort field
         * @param {ProjectsControllerFindPaginatedSortOrderEnum} [sortOrder] Sort order
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async projectsControllerFindPaginated(page?: number, limit?: number, search?: string, sortBy?: ProjectsControllerFindPaginatedSortByEnum, sortOrder?: ProjectsControllerFindPaginatedSortOrderEnum, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProjectsControllerFindPaginated200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.projectsControllerFindPaginated(page, limit, search, sortBy, sortOrder, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProjectsApi.projectsControllerFindPaginated']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns project statistics including counts and recent activity. Requires view:project permission.
         * @summary Get project statistics
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async projectsControllerGetStats(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProjectsControllerGetStats200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.projectsControllerGetStats(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProjectsApi.projectsControllerGetStats']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Deletes a project by ID. Requires delete:project permission.
         * @summary Delete project
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async projectsControllerRemove(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.projectsControllerRemove(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProjectsApi.projectsControllerRemove']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Updates a project by ID. Requires edit:project permission.
         * @summary Update project
         * @param {string} id 
         * @param {UpdateProjectDto} updateProjectDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async projectsControllerUpdate(id: string, updateProjectDto: UpdateProjectDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.projectsControllerUpdate(id, updateProjectDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProjectsApi.projectsControllerUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ProjectsApi - factory interface
 * @export
 */
export const ProjectsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ProjectsApiFp(configuration)
    return {
        /**
         * Creates a new project. Requires create:project permission.
         * @summary Create a new project
         * @param {CreateProjectDto} createProjectDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectsControllerCreate(createProjectDto: CreateProjectDto, options?: RawAxiosRequestConfig): AxiosPromise<ProjectsControllerCreate200Response> {
            return localVarFp.projectsControllerCreate(createProjectDto, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns all projects. Requires view:project permission.
         * @summary Get all projects (deprecated - use /projects/paginated instead)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectsControllerFindAll(options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.projectsControllerFindAll(options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a specific project by ID. Requires view:project permission.
         * @summary Get project by id
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectsControllerFindOne(id: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.projectsControllerFindOne(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns paginated projects with optional search and sorting. Requires view:project permission.
         * @summary Get paginated projects with search and sort
         * @param {number} [page] Page number for pagination
         * @param {number} [limit] Number of items per page
         * @param {string} [search] Search term to filter projects by name
         * @param {ProjectsControllerFindPaginatedSortByEnum} [sortBy] Sort field
         * @param {ProjectsControllerFindPaginatedSortOrderEnum} [sortOrder] Sort order
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectsControllerFindPaginated(page?: number, limit?: number, search?: string, sortBy?: ProjectsControllerFindPaginatedSortByEnum, sortOrder?: ProjectsControllerFindPaginatedSortOrderEnum, options?: RawAxiosRequestConfig): AxiosPromise<ProjectsControllerFindPaginated200Response> {
            return localVarFp.projectsControllerFindPaginated(page, limit, search, sortBy, sortOrder, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns project statistics including counts and recent activity. Requires view:project permission.
         * @summary Get project statistics
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectsControllerGetStats(options?: RawAxiosRequestConfig): AxiosPromise<ProjectsControllerGetStats200Response> {
            return localVarFp.projectsControllerGetStats(options).then((request) => request(axios, basePath));
        },
        /**
         * Deletes a project by ID. Requires delete:project permission.
         * @summary Delete project
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectsControllerRemove(id: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.projectsControllerRemove(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Updates a project by ID. Requires edit:project permission.
         * @summary Update project
         * @param {string} id 
         * @param {UpdateProjectDto} updateProjectDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectsControllerUpdate(id: string, updateProjectDto: UpdateProjectDto, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.projectsControllerUpdate(id, updateProjectDto, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ProjectsApi - interface
 * @export
 * @interface ProjectsApi
 */
export interface ProjectsApiInterface {
    /**
     * Creates a new project. Requires create:project permission.
     * @summary Create a new project
     * @param {CreateProjectDto} createProjectDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectsApiInterface
     */
    projectsControllerCreate(createProjectDto: CreateProjectDto, options?: RawAxiosRequestConfig): AxiosPromise<ProjectsControllerCreate200Response>;

    /**
     * Returns all projects. Requires view:project permission.
     * @summary Get all projects (deprecated - use /projects/paginated instead)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectsApiInterface
     */
    projectsControllerFindAll(options?: RawAxiosRequestConfig): AxiosPromise<void>;

    /**
     * Returns a specific project by ID. Requires view:project permission.
     * @summary Get project by id
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectsApiInterface
     */
    projectsControllerFindOne(id: string, options?: RawAxiosRequestConfig): AxiosPromise<void>;

    /**
     * Returns paginated projects with optional search and sorting. Requires view:project permission.
     * @summary Get paginated projects with search and sort
     * @param {number} [page] Page number for pagination
     * @param {number} [limit] Number of items per page
     * @param {string} [search] Search term to filter projects by name
     * @param {ProjectsControllerFindPaginatedSortByEnum} [sortBy] Sort field
     * @param {ProjectsControllerFindPaginatedSortOrderEnum} [sortOrder] Sort order
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectsApiInterface
     */
    projectsControllerFindPaginated(page?: number, limit?: number, search?: string, sortBy?: ProjectsControllerFindPaginatedSortByEnum, sortOrder?: ProjectsControllerFindPaginatedSortOrderEnum, options?: RawAxiosRequestConfig): AxiosPromise<ProjectsControllerFindPaginated200Response>;

    /**
     * Returns project statistics including counts and recent activity. Requires view:project permission.
     * @summary Get project statistics
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectsApiInterface
     */
    projectsControllerGetStats(options?: RawAxiosRequestConfig): AxiosPromise<ProjectsControllerGetStats200Response>;

    /**
     * Deletes a project by ID. Requires delete:project permission.
     * @summary Delete project
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectsApiInterface
     */
    projectsControllerRemove(id: string, options?: RawAxiosRequestConfig): AxiosPromise<void>;

    /**
     * Updates a project by ID. Requires edit:project permission.
     * @summary Update project
     * @param {string} id 
     * @param {UpdateProjectDto} updateProjectDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectsApiInterface
     */
    projectsControllerUpdate(id: string, updateProjectDto: UpdateProjectDto, options?: RawAxiosRequestConfig): AxiosPromise<void>;

}

/**
 * ProjectsApi - object-oriented interface
 * @export
 * @class ProjectsApi
 * @extends {BaseAPI}
 */
export class ProjectsApi extends BaseAPI implements ProjectsApiInterface {
    /**
     * Creates a new project. Requires create:project permission.
     * @summary Create a new project
     * @param {CreateProjectDto} createProjectDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectsApi
     */
    public projectsControllerCreate(createProjectDto: CreateProjectDto, options?: RawAxiosRequestConfig) {
        return ProjectsApiFp(this.configuration).projectsControllerCreate(createProjectDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns all projects. Requires view:project permission.
     * @summary Get all projects (deprecated - use /projects/paginated instead)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectsApi
     */
    public projectsControllerFindAll(options?: RawAxiosRequestConfig) {
        return ProjectsApiFp(this.configuration).projectsControllerFindAll(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a specific project by ID. Requires view:project permission.
     * @summary Get project by id
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectsApi
     */
    public projectsControllerFindOne(id: string, options?: RawAxiosRequestConfig) {
        return ProjectsApiFp(this.configuration).projectsControllerFindOne(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns paginated projects with optional search and sorting. Requires view:project permission.
     * @summary Get paginated projects with search and sort
     * @param {number} [page] Page number for pagination
     * @param {number} [limit] Number of items per page
     * @param {string} [search] Search term to filter projects by name
     * @param {ProjectsControllerFindPaginatedSortByEnum} [sortBy] Sort field
     * @param {ProjectsControllerFindPaginatedSortOrderEnum} [sortOrder] Sort order
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectsApi
     */
    public projectsControllerFindPaginated(page?: number, limit?: number, search?: string, sortBy?: ProjectsControllerFindPaginatedSortByEnum, sortOrder?: ProjectsControllerFindPaginatedSortOrderEnum, options?: RawAxiosRequestConfig) {
        return ProjectsApiFp(this.configuration).projectsControllerFindPaginated(page, limit, search, sortBy, sortOrder, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns project statistics including counts and recent activity. Requires view:project permission.
     * @summary Get project statistics
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectsApi
     */
    public projectsControllerGetStats(options?: RawAxiosRequestConfig) {
        return ProjectsApiFp(this.configuration).projectsControllerGetStats(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Deletes a project by ID. Requires delete:project permission.
     * @summary Delete project
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectsApi
     */
    public projectsControllerRemove(id: string, options?: RawAxiosRequestConfig) {
        return ProjectsApiFp(this.configuration).projectsControllerRemove(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Updates a project by ID. Requires edit:project permission.
     * @summary Update project
     * @param {string} id 
     * @param {UpdateProjectDto} updateProjectDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectsApi
     */
    public projectsControllerUpdate(id: string, updateProjectDto: UpdateProjectDto, options?: RawAxiosRequestConfig) {
        return ProjectsApiFp(this.configuration).projectsControllerUpdate(id, updateProjectDto, options).then((request) => request(this.axios, this.basePath));
    }
}

/**
  * @export
  * @enum {string}
  */
export enum ProjectsControllerFindPaginatedSortByEnum {
    Name = 'name',
    CreatedAt = 'createdAt'
}
/**
  * @export
  * @enum {string}
  */
export enum ProjectsControllerFindPaginatedSortOrderEnum {
    Asc = 'asc',
    Desc = 'desc'
}


/**
 * RoleManagementApi - axios parameter creator
 * @export
 */
export const RoleManagementApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Assign a role to a user in this project. Requires edit:user permission.
         * @summary Assign role to user
         * @param {string} projectId Project ID (UUID)
         * @param {string} userId User ID (UUID)
         * @param {AssignRoleDto} assignRoleDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rolesControllerAssignRole: async (projectId: string, userId: string, assignRoleDto: AssignRoleDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('rolesControllerAssignRole', 'projectId', projectId)
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('rolesControllerAssignRole', 'userId', userId)
            // verify required parameter 'assignRoleDto' is not null or undefined
            assertParamExists('rolesControllerAssignRole', 'assignRoleDto', assignRoleDto)
            const localVarPath = `/projects/{projectId}/roles/users/{userId}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(assignRoleDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Assign the same role to multiple users. Requires admin:system permission.
         * @summary Batch assign roles
         * @param {string} projectId Project ID (UUID)
         * @param {BulkAssignRoleDto} bulkAssignRoleDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rolesControllerBatchAssignRole: async (projectId: string, bulkAssignRoleDto: BulkAssignRoleDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('rolesControllerBatchAssignRole', 'projectId', projectId)
            // verify required parameter 'bulkAssignRoleDto' is not null or undefined
            assertParamExists('rolesControllerBatchAssignRole', 'bulkAssignRoleDto', bulkAssignRoleDto)
            const localVarPath = `/projects/{projectId}/roles/batch-assign`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(bulkAssignRoleDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve audit log of role assignments and removals for this project.
         * @summary Get role assignment audit log
         * @param {string} projectId Project ID (UUID)
         * @param {string} [userId] Filter by user ID
         * @param {string} [performedBy] Filter by admin who performed action
         * @param {number} [limit] Results per page (default: 50)
         * @param {number} [page] Page number (default: 1)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rolesControllerGetRoleAuditLog: async (projectId: string, userId?: string, performedBy?: string, limit?: number, page?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('rolesControllerGetRoleAuditLog', 'projectId', projectId)
            const localVarPath = `/projects/{projectId}/roles/audit`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (userId !== undefined) {
                localVarQueryParameter['userId'] = userId;
            }

            if (performedBy !== undefined) {
                localVarQueryParameter['performedBy'] = performedBy;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get all roles assigned to a specific user in this project.
         * @summary Get user roles in project
         * @param {string} projectId Project ID (UUID)
         * @param {string} userId User ID (UUID)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rolesControllerGetUserRoles: async (projectId: string, userId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('rolesControllerGetUserRoles', 'projectId', projectId)
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('rolesControllerGetUserRoles', 'userId', userId)
            const localVarPath = `/projects/{projectId}/roles/users/{userId}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get all users in this project with their assigned roles.
         * @summary List users in project
         * @param {string} projectId Project ID (UUID)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rolesControllerListProjectUsers: async (projectId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('rolesControllerListProjectUsers', 'projectId', projectId)
            const localVarPath = `/projects/{projectId}/roles/users`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get all roles available in the system with their permissions.
         * @summary List all available roles
         * @param {string} projectId Project ID (UUID)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rolesControllerListRoles: async (projectId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('rolesControllerListRoles', 'projectId', projectId)
            const localVarPath = `/projects/{projectId}/roles`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Remove a role from a user in this project. Requires edit:user permission.
         * @summary Remove role from user
         * @param {string} projectId Project ID (UUID)
         * @param {string} userId User ID (UUID)
         * @param {string} roleName Role name to remove
         * @param {string} [reason] Reason for removal
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rolesControllerRemoveRole: async (projectId: string, userId: string, roleName: string, reason?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('rolesControllerRemoveRole', 'projectId', projectId)
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('rolesControllerRemoveRole', 'userId', userId)
            // verify required parameter 'roleName' is not null or undefined
            assertParamExists('rolesControllerRemoveRole', 'roleName', roleName)
            const localVarPath = `/projects/{projectId}/roles/users/{userId}/roles/{roleName}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)))
                .replace(`{${"roleName"}}`, encodeURIComponent(String(roleName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (reason !== undefined) {
                localVarQueryParameter['reason'] = reason;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * RoleManagementApi - functional programming interface
 * @export
 */
export const RoleManagementApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = RoleManagementApiAxiosParamCreator(configuration)
    return {
        /**
         * Assign a role to a user in this project. Requires edit:user permission.
         * @summary Assign role to user
         * @param {string} projectId Project ID (UUID)
         * @param {string} userId User ID (UUID)
         * @param {AssignRoleDto} assignRoleDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async rolesControllerAssignRole(projectId: string, userId: string, assignRoleDto: AssignRoleDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.rolesControllerAssignRole(projectId, userId, assignRoleDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RoleManagementApi.rolesControllerAssignRole']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Assign the same role to multiple users. Requires admin:system permission.
         * @summary Batch assign roles
         * @param {string} projectId Project ID (UUID)
         * @param {BulkAssignRoleDto} bulkAssignRoleDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async rolesControllerBatchAssignRole(projectId: string, bulkAssignRoleDto: BulkAssignRoleDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BulkOperationResultDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.rolesControllerBatchAssignRole(projectId, bulkAssignRoleDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RoleManagementApi.rolesControllerBatchAssignRole']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve audit log of role assignments and removals for this project.
         * @summary Get role assignment audit log
         * @param {string} projectId Project ID (UUID)
         * @param {string} [userId] Filter by user ID
         * @param {string} [performedBy] Filter by admin who performed action
         * @param {number} [limit] Results per page (default: 50)
         * @param {number} [page] Page number (default: 1)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async rolesControllerGetRoleAuditLog(projectId: string, userId?: string, performedBy?: string, limit?: number, page?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AuditLogResponseDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.rolesControllerGetRoleAuditLog(projectId, userId, performedBy, limit, page, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RoleManagementApi.rolesControllerGetRoleAuditLog']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get all roles assigned to a specific user in this project.
         * @summary Get user roles in project
         * @param {string} projectId Project ID (UUID)
         * @param {string} userId User ID (UUID)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async rolesControllerGetUserRoles(projectId: string, userId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserWithRolesDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.rolesControllerGetUserRoles(projectId, userId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RoleManagementApi.rolesControllerGetUserRoles']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get all users in this project with their assigned roles.
         * @summary List users in project
         * @param {string} projectId Project ID (UUID)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async rolesControllerListProjectUsers(projectId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProjectUsersResponseDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.rolesControllerListProjectUsers(projectId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RoleManagementApi.rolesControllerListProjectUsers']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get all roles available in the system with their permissions.
         * @summary List all available roles
         * @param {string} projectId Project ID (UUID)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async rolesControllerListRoles(projectId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<RoleDto>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.rolesControllerListRoles(projectId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RoleManagementApi.rolesControllerListRoles']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Remove a role from a user in this project. Requires edit:user permission.
         * @summary Remove role from user
         * @param {string} projectId Project ID (UUID)
         * @param {string} userId User ID (UUID)
         * @param {string} roleName Role name to remove
         * @param {string} [reason] Reason for removal
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async rolesControllerRemoveRole(projectId: string, userId: string, roleName: string, reason?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.rolesControllerRemoveRole(projectId, userId, roleName, reason, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RoleManagementApi.rolesControllerRemoveRole']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * RoleManagementApi - factory interface
 * @export
 */
export const RoleManagementApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = RoleManagementApiFp(configuration)
    return {
        /**
         * Assign a role to a user in this project. Requires edit:user permission.
         * @summary Assign role to user
         * @param {string} projectId Project ID (UUID)
         * @param {string} userId User ID (UUID)
         * @param {AssignRoleDto} assignRoleDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rolesControllerAssignRole(projectId: string, userId: string, assignRoleDto: AssignRoleDto, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.rolesControllerAssignRole(projectId, userId, assignRoleDto, options).then((request) => request(axios, basePath));
        },
        /**
         * Assign the same role to multiple users. Requires admin:system permission.
         * @summary Batch assign roles
         * @param {string} projectId Project ID (UUID)
         * @param {BulkAssignRoleDto} bulkAssignRoleDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rolesControllerBatchAssignRole(projectId: string, bulkAssignRoleDto: BulkAssignRoleDto, options?: RawAxiosRequestConfig): AxiosPromise<BulkOperationResultDto> {
            return localVarFp.rolesControllerBatchAssignRole(projectId, bulkAssignRoleDto, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve audit log of role assignments and removals for this project.
         * @summary Get role assignment audit log
         * @param {string} projectId Project ID (UUID)
         * @param {string} [userId] Filter by user ID
         * @param {string} [performedBy] Filter by admin who performed action
         * @param {number} [limit] Results per page (default: 50)
         * @param {number} [page] Page number (default: 1)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rolesControllerGetRoleAuditLog(projectId: string, userId?: string, performedBy?: string, limit?: number, page?: number, options?: RawAxiosRequestConfig): AxiosPromise<AuditLogResponseDto> {
            return localVarFp.rolesControllerGetRoleAuditLog(projectId, userId, performedBy, limit, page, options).then((request) => request(axios, basePath));
        },
        /**
         * Get all roles assigned to a specific user in this project.
         * @summary Get user roles in project
         * @param {string} projectId Project ID (UUID)
         * @param {string} userId User ID (UUID)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rolesControllerGetUserRoles(projectId: string, userId: string, options?: RawAxiosRequestConfig): AxiosPromise<UserWithRolesDto> {
            return localVarFp.rolesControllerGetUserRoles(projectId, userId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get all users in this project with their assigned roles.
         * @summary List users in project
         * @param {string} projectId Project ID (UUID)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rolesControllerListProjectUsers(projectId: string, options?: RawAxiosRequestConfig): AxiosPromise<ProjectUsersResponseDto> {
            return localVarFp.rolesControllerListProjectUsers(projectId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get all roles available in the system with their permissions.
         * @summary List all available roles
         * @param {string} projectId Project ID (UUID)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rolesControllerListRoles(projectId: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<RoleDto>> {
            return localVarFp.rolesControllerListRoles(projectId, options).then((request) => request(axios, basePath));
        },
        /**
         * Remove a role from a user in this project. Requires edit:user permission.
         * @summary Remove role from user
         * @param {string} projectId Project ID (UUID)
         * @param {string} userId User ID (UUID)
         * @param {string} roleName Role name to remove
         * @param {string} [reason] Reason for removal
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rolesControllerRemoveRole(projectId: string, userId: string, roleName: string, reason?: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.rolesControllerRemoveRole(projectId, userId, roleName, reason, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * RoleManagementApi - interface
 * @export
 * @interface RoleManagementApi
 */
export interface RoleManagementApiInterface {
    /**
     * Assign a role to a user in this project. Requires edit:user permission.
     * @summary Assign role to user
     * @param {string} projectId Project ID (UUID)
     * @param {string} userId User ID (UUID)
     * @param {AssignRoleDto} assignRoleDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RoleManagementApiInterface
     */
    rolesControllerAssignRole(projectId: string, userId: string, assignRoleDto: AssignRoleDto, options?: RawAxiosRequestConfig): AxiosPromise<void>;

    /**
     * Assign the same role to multiple users. Requires admin:system permission.
     * @summary Batch assign roles
     * @param {string} projectId Project ID (UUID)
     * @param {BulkAssignRoleDto} bulkAssignRoleDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RoleManagementApiInterface
     */
    rolesControllerBatchAssignRole(projectId: string, bulkAssignRoleDto: BulkAssignRoleDto, options?: RawAxiosRequestConfig): AxiosPromise<BulkOperationResultDto>;

    /**
     * Retrieve audit log of role assignments and removals for this project.
     * @summary Get role assignment audit log
     * @param {string} projectId Project ID (UUID)
     * @param {string} [userId] Filter by user ID
     * @param {string} [performedBy] Filter by admin who performed action
     * @param {number} [limit] Results per page (default: 50)
     * @param {number} [page] Page number (default: 1)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RoleManagementApiInterface
     */
    rolesControllerGetRoleAuditLog(projectId: string, userId?: string, performedBy?: string, limit?: number, page?: number, options?: RawAxiosRequestConfig): AxiosPromise<AuditLogResponseDto>;

    /**
     * Get all roles assigned to a specific user in this project.
     * @summary Get user roles in project
     * @param {string} projectId Project ID (UUID)
     * @param {string} userId User ID (UUID)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RoleManagementApiInterface
     */
    rolesControllerGetUserRoles(projectId: string, userId: string, options?: RawAxiosRequestConfig): AxiosPromise<UserWithRolesDto>;

    /**
     * Get all users in this project with their assigned roles.
     * @summary List users in project
     * @param {string} projectId Project ID (UUID)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RoleManagementApiInterface
     */
    rolesControllerListProjectUsers(projectId: string, options?: RawAxiosRequestConfig): AxiosPromise<ProjectUsersResponseDto>;

    /**
     * Get all roles available in the system with their permissions.
     * @summary List all available roles
     * @param {string} projectId Project ID (UUID)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RoleManagementApiInterface
     */
    rolesControllerListRoles(projectId: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<RoleDto>>;

    /**
     * Remove a role from a user in this project. Requires edit:user permission.
     * @summary Remove role from user
     * @param {string} projectId Project ID (UUID)
     * @param {string} userId User ID (UUID)
     * @param {string} roleName Role name to remove
     * @param {string} [reason] Reason for removal
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RoleManagementApiInterface
     */
    rolesControllerRemoveRole(projectId: string, userId: string, roleName: string, reason?: string, options?: RawAxiosRequestConfig): AxiosPromise<void>;

}

/**
 * RoleManagementApi - object-oriented interface
 * @export
 * @class RoleManagementApi
 * @extends {BaseAPI}
 */
export class RoleManagementApi extends BaseAPI implements RoleManagementApiInterface {
    /**
     * Assign a role to a user in this project. Requires edit:user permission.
     * @summary Assign role to user
     * @param {string} projectId Project ID (UUID)
     * @param {string} userId User ID (UUID)
     * @param {AssignRoleDto} assignRoleDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RoleManagementApi
     */
    public rolesControllerAssignRole(projectId: string, userId: string, assignRoleDto: AssignRoleDto, options?: RawAxiosRequestConfig) {
        return RoleManagementApiFp(this.configuration).rolesControllerAssignRole(projectId, userId, assignRoleDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Assign the same role to multiple users. Requires admin:system permission.
     * @summary Batch assign roles
     * @param {string} projectId Project ID (UUID)
     * @param {BulkAssignRoleDto} bulkAssignRoleDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RoleManagementApi
     */
    public rolesControllerBatchAssignRole(projectId: string, bulkAssignRoleDto: BulkAssignRoleDto, options?: RawAxiosRequestConfig) {
        return RoleManagementApiFp(this.configuration).rolesControllerBatchAssignRole(projectId, bulkAssignRoleDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve audit log of role assignments and removals for this project.
     * @summary Get role assignment audit log
     * @param {string} projectId Project ID (UUID)
     * @param {string} [userId] Filter by user ID
     * @param {string} [performedBy] Filter by admin who performed action
     * @param {number} [limit] Results per page (default: 50)
     * @param {number} [page] Page number (default: 1)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RoleManagementApi
     */
    public rolesControllerGetRoleAuditLog(projectId: string, userId?: string, performedBy?: string, limit?: number, page?: number, options?: RawAxiosRequestConfig) {
        return RoleManagementApiFp(this.configuration).rolesControllerGetRoleAuditLog(projectId, userId, performedBy, limit, page, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get all roles assigned to a specific user in this project.
     * @summary Get user roles in project
     * @param {string} projectId Project ID (UUID)
     * @param {string} userId User ID (UUID)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RoleManagementApi
     */
    public rolesControllerGetUserRoles(projectId: string, userId: string, options?: RawAxiosRequestConfig) {
        return RoleManagementApiFp(this.configuration).rolesControllerGetUserRoles(projectId, userId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get all users in this project with their assigned roles.
     * @summary List users in project
     * @param {string} projectId Project ID (UUID)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RoleManagementApi
     */
    public rolesControllerListProjectUsers(projectId: string, options?: RawAxiosRequestConfig) {
        return RoleManagementApiFp(this.configuration).rolesControllerListProjectUsers(projectId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get all roles available in the system with their permissions.
     * @summary List all available roles
     * @param {string} projectId Project ID (UUID)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RoleManagementApi
     */
    public rolesControllerListRoles(projectId: string, options?: RawAxiosRequestConfig) {
        return RoleManagementApiFp(this.configuration).rolesControllerListRoles(projectId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Remove a role from a user in this project. Requires edit:user permission.
     * @summary Remove role from user
     * @param {string} projectId Project ID (UUID)
     * @param {string} userId User ID (UUID)
     * @param {string} roleName Role name to remove
     * @param {string} [reason] Reason for removal
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RoleManagementApi
     */
    public rolesControllerRemoveRole(projectId: string, userId: string, roleName: string, reason?: string, options?: RawAxiosRequestConfig) {
        return RoleManagementApiFp(this.configuration).rolesControllerRemoveRole(projectId, userId, roleName, reason, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * UsersApi - axios parameter creator
 * @export
 */
export const UsersApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Creates a new user. Requires create:user permission. Typically restricted to project_admin role.
         * @summary Create a new user
         * @param {CreateUserDto} createUserDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersControllerCreate: async (createUserDto: CreateUserDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createUserDto' is not null or undefined
            assertParamExists('usersControllerCreate', 'createUserDto', createUserDto)
            const localVarPath = `/users`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createUserDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Creates multiple users in a single operation. Requires create:user permission. Typically restricted to project_admin role.
         * @summary Create multiple users
         * @param {Array<string>} requestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersControllerCreateBulk: async (requestBody: Array<string>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'requestBody' is not null or undefined
            assertParamExists('usersControllerCreateBulk', 'requestBody', requestBody)
            const localVarPath = `/users/bulk`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(requestBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns all users. Requires view:user permission.
         * @summary Get all users (deprecated - use /users/paginated instead)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersControllerFindAll: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/users`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a specific user by ID. Requires view:user permission.
         * @summary Get user by id
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersControllerFindOne: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('usersControllerFindOne', 'id', id)
            const localVarPath = `/users/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns paginated users with optional search and sorting. Requires view:user permission.
         * @summary Get paginated users with search and sort
         * @param {number} [page] 
         * @param {number} [limit] 
         * @param {string} [search] Search by name or email
         * @param {UsersControllerFindPaginatedSortByEnum} [sortBy] 
         * @param {UsersControllerFindPaginatedSortOrderEnum} [sortOrder] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersControllerFindPaginated: async (page?: number, limit?: number, search?: string, sortBy?: UsersControllerFindPaginatedSortByEnum, sortOrder?: UsersControllerFindPaginatedSortOrderEnum, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/users/paginated`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sortBy'] = sortBy;
            }

            if (sortOrder !== undefined) {
                localVarQueryParameter['sortOrder'] = sortOrder;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns user statistics including counts and recent activity. Requires view:user permission.
         * @summary Get user statistics
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersControllerGetStats: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/users/stats`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Deletes a user by ID. Requires delete:user permission. Typically restricted to project_admin role.
         * @summary Delete user
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersControllerRemove: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('usersControllerRemove', 'id', id)
            const localVarPath = `/users/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates a user by ID. Requires edit:user permission. Typically restricted to project_admin role.
         * @summary Update user
         * @param {string} id 
         * @param {UpdateUserDto} updateUserDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersControllerUpdate: async (id: string, updateUserDto: UpdateUserDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('usersControllerUpdate', 'id', id)
            // verify required parameter 'updateUserDto' is not null or undefined
            assertParamExists('usersControllerUpdate', 'updateUserDto', updateUserDto)
            const localVarPath = `/users/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateUserDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UsersApi - functional programming interface
 * @export
 */
export const UsersApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = UsersApiAxiosParamCreator(configuration)
    return {
        /**
         * Creates a new user. Requires create:user permission. Typically restricted to project_admin role.
         * @summary Create a new user
         * @param {CreateUserDto} createUserDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async usersControllerCreate(createUserDto: CreateUserDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UsersControllerCreate200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.usersControllerCreate(createUserDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.usersControllerCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Creates multiple users in a single operation. Requires create:user permission. Typically restricted to project_admin role.
         * @summary Create multiple users
         * @param {Array<string>} requestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async usersControllerCreateBulk(requestBody: Array<string>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<object>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.usersControllerCreateBulk(requestBody, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.usersControllerCreateBulk']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns all users. Requires view:user permission.
         * @summary Get all users (deprecated - use /users/paginated instead)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async usersControllerFindAll(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.usersControllerFindAll(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.usersControllerFindAll']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns a specific user by ID. Requires view:user permission.
         * @summary Get user by id
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async usersControllerFindOne(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.usersControllerFindOne(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.usersControllerFindOne']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns paginated users with optional search and sorting. Requires view:user permission.
         * @summary Get paginated users with search and sort
         * @param {number} [page] 
         * @param {number} [limit] 
         * @param {string} [search] Search by name or email
         * @param {UsersControllerFindPaginatedSortByEnum} [sortBy] 
         * @param {UsersControllerFindPaginatedSortOrderEnum} [sortOrder] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async usersControllerFindPaginated(page?: number, limit?: number, search?: string, sortBy?: UsersControllerFindPaginatedSortByEnum, sortOrder?: UsersControllerFindPaginatedSortOrderEnum, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UsersControllerFindPaginated200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.usersControllerFindPaginated(page, limit, search, sortBy, sortOrder, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.usersControllerFindPaginated']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns user statistics including counts and recent activity. Requires view:user permission.
         * @summary Get user statistics
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async usersControllerGetStats(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UsersControllerGetStats200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.usersControllerGetStats(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.usersControllerGetStats']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Deletes a user by ID. Requires delete:user permission. Typically restricted to project_admin role.
         * @summary Delete user
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async usersControllerRemove(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.usersControllerRemove(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.usersControllerRemove']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Updates a user by ID. Requires edit:user permission. Typically restricted to project_admin role.
         * @summary Update user
         * @param {string} id 
         * @param {UpdateUserDto} updateUserDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async usersControllerUpdate(id: string, updateUserDto: UpdateUserDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.usersControllerUpdate(id, updateUserDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.usersControllerUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * UsersApi - factory interface
 * @export
 */
export const UsersApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = UsersApiFp(configuration)
    return {
        /**
         * Creates a new user. Requires create:user permission. Typically restricted to project_admin role.
         * @summary Create a new user
         * @param {CreateUserDto} createUserDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersControllerCreate(createUserDto: CreateUserDto, options?: RawAxiosRequestConfig): AxiosPromise<UsersControllerCreate200Response> {
            return localVarFp.usersControllerCreate(createUserDto, options).then((request) => request(axios, basePath));
        },
        /**
         * Creates multiple users in a single operation. Requires create:user permission. Typically restricted to project_admin role.
         * @summary Create multiple users
         * @param {Array<string>} requestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersControllerCreateBulk(requestBody: Array<string>, options?: RawAxiosRequestConfig): AxiosPromise<Array<object>> {
            return localVarFp.usersControllerCreateBulk(requestBody, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns all users. Requires view:user permission.
         * @summary Get all users (deprecated - use /users/paginated instead)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersControllerFindAll(options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.usersControllerFindAll(options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a specific user by ID. Requires view:user permission.
         * @summary Get user by id
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersControllerFindOne(id: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.usersControllerFindOne(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns paginated users with optional search and sorting. Requires view:user permission.
         * @summary Get paginated users with search and sort
         * @param {number} [page] 
         * @param {number} [limit] 
         * @param {string} [search] Search by name or email
         * @param {UsersControllerFindPaginatedSortByEnum} [sortBy] 
         * @param {UsersControllerFindPaginatedSortOrderEnum} [sortOrder] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersControllerFindPaginated(page?: number, limit?: number, search?: string, sortBy?: UsersControllerFindPaginatedSortByEnum, sortOrder?: UsersControllerFindPaginatedSortOrderEnum, options?: RawAxiosRequestConfig): AxiosPromise<UsersControllerFindPaginated200Response> {
            return localVarFp.usersControllerFindPaginated(page, limit, search, sortBy, sortOrder, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns user statistics including counts and recent activity. Requires view:user permission.
         * @summary Get user statistics
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersControllerGetStats(options?: RawAxiosRequestConfig): AxiosPromise<UsersControllerGetStats200Response> {
            return localVarFp.usersControllerGetStats(options).then((request) => request(axios, basePath));
        },
        /**
         * Deletes a user by ID. Requires delete:user permission. Typically restricted to project_admin role.
         * @summary Delete user
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersControllerRemove(id: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.usersControllerRemove(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Updates a user by ID. Requires edit:user permission. Typically restricted to project_admin role.
         * @summary Update user
         * @param {string} id 
         * @param {UpdateUserDto} updateUserDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersControllerUpdate(id: string, updateUserDto: UpdateUserDto, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.usersControllerUpdate(id, updateUserDto, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * UsersApi - interface
 * @export
 * @interface UsersApi
 */
export interface UsersApiInterface {
    /**
     * Creates a new user. Requires create:user permission. Typically restricted to project_admin role.
     * @summary Create a new user
     * @param {CreateUserDto} createUserDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApiInterface
     */
    usersControllerCreate(createUserDto: CreateUserDto, options?: RawAxiosRequestConfig): AxiosPromise<UsersControllerCreate200Response>;

    /**
     * Creates multiple users in a single operation. Requires create:user permission. Typically restricted to project_admin role.
     * @summary Create multiple users
     * @param {Array<string>} requestBody 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApiInterface
     */
    usersControllerCreateBulk(requestBody: Array<string>, options?: RawAxiosRequestConfig): AxiosPromise<Array<object>>;

    /**
     * Returns all users. Requires view:user permission.
     * @summary Get all users (deprecated - use /users/paginated instead)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApiInterface
     */
    usersControllerFindAll(options?: RawAxiosRequestConfig): AxiosPromise<void>;

    /**
     * Returns a specific user by ID. Requires view:user permission.
     * @summary Get user by id
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApiInterface
     */
    usersControllerFindOne(id: string, options?: RawAxiosRequestConfig): AxiosPromise<void>;

    /**
     * Returns paginated users with optional search and sorting. Requires view:user permission.
     * @summary Get paginated users with search and sort
     * @param {number} [page] 
     * @param {number} [limit] 
     * @param {string} [search] Search by name or email
     * @param {UsersControllerFindPaginatedSortByEnum} [sortBy] 
     * @param {UsersControllerFindPaginatedSortOrderEnum} [sortOrder] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApiInterface
     */
    usersControllerFindPaginated(page?: number, limit?: number, search?: string, sortBy?: UsersControllerFindPaginatedSortByEnum, sortOrder?: UsersControllerFindPaginatedSortOrderEnum, options?: RawAxiosRequestConfig): AxiosPromise<UsersControllerFindPaginated200Response>;

    /**
     * Returns user statistics including counts and recent activity. Requires view:user permission.
     * @summary Get user statistics
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApiInterface
     */
    usersControllerGetStats(options?: RawAxiosRequestConfig): AxiosPromise<UsersControllerGetStats200Response>;

    /**
     * Deletes a user by ID. Requires delete:user permission. Typically restricted to project_admin role.
     * @summary Delete user
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApiInterface
     */
    usersControllerRemove(id: string, options?: RawAxiosRequestConfig): AxiosPromise<void>;

    /**
     * Updates a user by ID. Requires edit:user permission. Typically restricted to project_admin role.
     * @summary Update user
     * @param {string} id 
     * @param {UpdateUserDto} updateUserDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApiInterface
     */
    usersControllerUpdate(id: string, updateUserDto: UpdateUserDto, options?: RawAxiosRequestConfig): AxiosPromise<void>;

}

/**
 * UsersApi - object-oriented interface
 * @export
 * @class UsersApi
 * @extends {BaseAPI}
 */
export class UsersApi extends BaseAPI implements UsersApiInterface {
    /**
     * Creates a new user. Requires create:user permission. Typically restricted to project_admin role.
     * @summary Create a new user
     * @param {CreateUserDto} createUserDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public usersControllerCreate(createUserDto: CreateUserDto, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).usersControllerCreate(createUserDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Creates multiple users in a single operation. Requires create:user permission. Typically restricted to project_admin role.
     * @summary Create multiple users
     * @param {Array<string>} requestBody 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public usersControllerCreateBulk(requestBody: Array<string>, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).usersControllerCreateBulk(requestBody, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns all users. Requires view:user permission.
     * @summary Get all users (deprecated - use /users/paginated instead)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public usersControllerFindAll(options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).usersControllerFindAll(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a specific user by ID. Requires view:user permission.
     * @summary Get user by id
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public usersControllerFindOne(id: string, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).usersControllerFindOne(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns paginated users with optional search and sorting. Requires view:user permission.
     * @summary Get paginated users with search and sort
     * @param {number} [page] 
     * @param {number} [limit] 
     * @param {string} [search] Search by name or email
     * @param {UsersControllerFindPaginatedSortByEnum} [sortBy] 
     * @param {UsersControllerFindPaginatedSortOrderEnum} [sortOrder] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public usersControllerFindPaginated(page?: number, limit?: number, search?: string, sortBy?: UsersControllerFindPaginatedSortByEnum, sortOrder?: UsersControllerFindPaginatedSortOrderEnum, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).usersControllerFindPaginated(page, limit, search, sortBy, sortOrder, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns user statistics including counts and recent activity. Requires view:user permission.
     * @summary Get user statistics
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public usersControllerGetStats(options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).usersControllerGetStats(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Deletes a user by ID. Requires delete:user permission. Typically restricted to project_admin role.
     * @summary Delete user
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public usersControllerRemove(id: string, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).usersControllerRemove(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Updates a user by ID. Requires edit:user permission. Typically restricted to project_admin role.
     * @summary Update user
     * @param {string} id 
     * @param {UpdateUserDto} updateUserDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public usersControllerUpdate(id: string, updateUserDto: UpdateUserDto, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).usersControllerUpdate(id, updateUserDto, options).then((request) => request(this.axios, this.basePath));
    }
}

/**
  * @export
  * @enum {string}
  */
export enum UsersControllerFindPaginatedSortByEnum {
    Id = 'id',
    Name = 'name',
    Email = 'email',
    CreatedAt = 'createdAt'
}
/**
  * @export
  * @enum {string}
  */
export enum UsersControllerFindPaginatedSortOrderEnum {
    Asc = 'asc',
    Desc = 'desc'
}


